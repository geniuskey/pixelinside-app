<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë§ˆì´í¬ë¡œ ë Œì¦ˆ ì–´ë ˆì´ ì‹œê°í™” ë„êµ¬</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.16.1/plotly.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #3498db, #9b59b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .controls {
            margin-bottom: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            padding: 10px;
        }
        
        .control-section {
            margin-bottom: 10px;
        }
        
        .control-header {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        .control-header:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .control-header .arrow {
            font-size: 14px;
            transition: transform 0.3s ease;
        }
        
        .control-header.collapsed .arrow {
            transform: rotate(-90deg);
        }
        
        .control-content {
            background: white;
            border-radius: 0 0 10px 10px;
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .control-content.collapsed {
            max-height: 0;
            padding: 0 20px;
        }
        
        .control-item {
            margin-bottom: 15px;
        }
        
        .control-item label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 14px;
        }
        
        .control-item input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }
        
        .control-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
        
        .control-item select, .control-item button {
            width: 100%;
            padding: 8px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            background: white;
            font-size: 14px;
            cursor: pointer;
        }
        
        .control-item select:focus, .control-item button:focus {
            border-color: #3498db;
            outline: none;
        }
        
        .value-display {
            font-size: 12px;
            color: #7f8c8d;
            text-align: right;
        }
        
        .view-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .view-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        
        .view-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .view-btn.active {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }
        
        .plot-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        
        .info-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
        }
        
        .info-panel h3 {
            margin-top: 0;
        }
        
        .formula-compact {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-family: 'Times New Roman', serif;
            line-height: 1.6;
        }
        
        .math-formula {
            font-family: 'Times New Roman', serif;
            font-size: 14px;
            font-style: italic;
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            border-radius: 3px;
            display: inline;
            margin: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”¬ ë§ˆì´í¬ë¡œ ë Œì¦ˆ ì–´ë ˆì´ ì‹œê°í™” ë„êµ¬</h1>
        
        <div class="controls">
            <div class="control-section">
                <div class="control-header" onclick="toggleSection('config')">
                    <span>âš™ï¸ ì„¤ì • ê´€ë¦¬</span>
                    <span class="arrow">â–¼</span>
                </div>
                <div class="control-content collapsed" id="config-content">
                    <div class="control-item">
                        <button onclick="resetToDefaults()">ğŸ”„ ê¸°ë³¸ê°’ ë³µì›</button>
                        <button onclick="copyConfigurationToClipboard()">ğŸ“‹ ì„¤ì • ë³µì‚¬ (Copy)</button>
                    </div>
                    <div class="control-item">
                        <label for="configTextarea">ì„¤ì • ë¶™ì—¬ë„£ê¸°:</label>
                        <textarea id="configTextarea" rows="15" style="width: 100%; font-family: monospace; font-size: 12px; border: 2px solid #bdc3c7; border-radius: 5px; padding: 8px;" placeholder="ì—¬ê¸°ì— ì„¤ì • JSONì„ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”..."></textarea>
                        <button onclick="applyConfiguration()">âœ… ì„¤ì • ì ìš©</button>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <div class="control-header" onclick="toggleSection('visual')">
                    <span>ğŸ¨ ì‹œê°í™” ì„¤ì •</span>
                    <span class="arrow">â–¼</span>
                </div>
                <div class="control-content collapsed" id="visual-content">
                    <div class="control-item">
                        <label for="resolution">í•´ìƒë„:</label>
                        <input type="range" id="resolution" min="10" max="200" step="10" value="50">
                        <div class="value-display" id="resolutionValue">30</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="colormap">ìƒ‰ìƒ ë§µ:</label>
                        <select id="colormap">
                            <option value="Viridis">Viridis</option>
                            <option value="Plasma">Plasma</option>
                            <option value="Inferno">Inferno</option>
                            <option value="Magma">Magma</option>
                            <option value="Jet">Jet</option>
                            <option value="Hot">Hot</option>
                            <option value="Cool">Cool</option>
                            <option value="Rainbow">Rainbow</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <div class="control-header" onclick="toggleSection('array')">
                    <span>ğŸ”¢ ë°°ì—´ êµ¬ì„±</span>
                    <span class="arrow">â–¼</span>
                </div>
                <div class="control-content" id="array-content">
                    <div class="control-item">
                        <label for="arrayConfig">ë°°ì—´ êµ¬ì„±:</label>
                        <select id="arrayConfig">
                            <option value="1x1" selected>1Ã—1 (ë‹¨ì¼ ë Œì¦ˆ)</option>
                            <option value="2x1">2Ã—1 (ì„¸ë¡œ 2ê°œ)</option>
                            <option value="1x2">1Ã—2 (ê°€ë¡œ 2ê°œ)</option>
                            <option value="2x2">2Ã—2 (2Ã—2 ë°°ì—´)</option>
                            <option value="3x3">3Ã—3 (3Ã—3 ë°°ì—´)</option>
                            <option value="4x4">4Ã—4 (4Ã—4 ë°°ì—´)</option>
                        </select>
                    </div>
                    
                    <div class="control-item">
                        <label for="spacingX">ë Œì¦ˆ ê°„ê²© X (Î¼m):</label>
                        <input type="range" id="spacingX" min="0.1" max="2.0" step="0.01" value="1.0">
                        <div class="value-display" id="spacingXValue">1.0 Î¼m</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="spacingY">ë Œì¦ˆ ê°„ê²© Y (Î¼m):</label>
                        <input type="range" id="spacingY" min="0.1" max="2.0" step="0.01" value="1.0">
                        <div class="value-display" id="spacingYValue">1.0 Î¼m</div>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <div class="control-header" onclick="toggleSection('lens')">
                    <span>ğŸ” ë Œì¦ˆ í˜•íƒœ íŒŒë¼ë¯¸í„°</span>
                    <span class="arrow">â–¼</span>
                </div>
                <div class="control-content" id="lens-content">
                    <div class="control-item">
                        <label for="Rx">ë°˜ì§€ë¦„ X (Rx, Î¼m):</label>
                        <input type="range" id="Rx" min="0.1" max="3.0" step="0.01" value="0.6">
                        <div class="value-display" id="RxValue">0.6 Î¼m</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="Ry">ë°˜ì§€ë¦„ Y (Ry, Î¼m):</label>
                        <input type="range" id="Ry" min="0.1" max="3.0" step="0.01" value="0.6">
                        <div class="value-display" id="RyValue">0.6 Î¼m</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="h">ë†’ì´ (h, Î¼m):</label>
                        <input type="range" id="h" min="0.1" max="1.0" step="0.01" value="0.5">
                        <div class="value-display" id="hValue">0.5 Î¼m</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="n">ìŠˆí¼ì—˜ë¦½ìŠ¤ ì§€ìˆ˜ (n):</label>
                        <input type="range" id="n" min="1.0" max="5.0" step="0.05" value="2.0">
                        <div class="value-display" id="nValue">2.0</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="alpha">ê³¡ë¥  íŒŒë¼ë¯¸í„° (Î±):</label>
                        <input type="range" id="alpha" min="0.1" max="2.0" step="0.01" value="1.0">
                        <div class="value-display" id="alphaValue">1.0</div>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <div class="control-header" onclick="toggleSection('ray')">
                    <span>ğŸŒˆ ê´‘ì„  ì¶”ì  ì„¤ì •</span>
                    <span class="arrow">â–¼</span>
                </div>
                <div class="control-content collapsed" id="ray-content">
                    <div class="control-item">
                        <label for="numRays">ê´‘ì„  ìˆ˜ (per ë Œì¦ˆ):</label>
                        <input type="range" id="numRays" min="3" max="50" step="5" value="20">
                        <div class="value-display" id="numRaysValue">20</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="refractiveIndex">êµ´ì ˆë¥  (n):</label>
                        <input type="range" id="refractiveIndex" min="1.3" max="1.6" step="0.01" value="1.5">
                        <div class="value-display" id="refractiveIndexValue">1.5</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="propagationDistance">ì „íŒŒ ê±°ë¦¬ (Î¼m):</label>
                        <input type="range" id="propagationDistance" min="1" max="80" step="1" value="2">
                        <div class="value-display" id="propagationDistanceValue">2 Î¼m</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="raySpacing">ê´‘ì„  ê°„ê²©:</label>
                        <input type="range" id="raySpacing" min="0.1" max="1.0" step="0.01" value="0.9">
                        <div class="value-display" id="raySpacingValue">0.9</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="view-controls">
            <button class="view-btn active" id="viewContour">ì»¨íˆ¬ì–´ ë·°</button>
            <button class="view-btn" id="view2D">2D ë“±ê³ ì„  ë·°</button>
            <button class="view-btn" id="view3D">3D ì„œí”¼ìŠ¤ ë·°</button>
            <button class="view-btn" id="viewRay2D">2D ê´‘ì„  ì¶”ì </button>
            <button class="view-btn" id="viewRay3D">3D ê´‘ì„  ì¶”ì </button>
        </div>
        
        <div class="plot-container">
            <div id="plot" style="width: 100%; height: 600px;"></div>
        </div>
        
        <div class="plot-container" id="multiViewContainer" style="display: none;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; height: 800px;">
                <div id="topView" style="height: 380px;"></div>
                <div id="diagonalView" style="height: 380px;"></div>
                <div id="sideViewXZ" style="height: 380px;"></div>
                <div id="sideViewYZ" style="height: 380px;"></div>
            </div>
        </div>
        
        <div class="info-panel">
            <h3>ğŸ“ ìˆ˜í•™ì  ëª¨ë¸</h3>
            <div class="formula-compact">
                <strong>ìŠˆí¼ì—˜ë¦½ìŠ¤ ë°©ì •ì‹:</strong> <span class="math-formula">|x/Rx|^n + |y/Ry|^n = 1</span><br>
                <strong>ë Œì¦ˆ ë†’ì´ ë°©ì •ì‹:</strong> <span class="math-formula">z(r) = h Ã— (1 - rÂ²)^(1/(2Î±))</span><br>
                <strong>ê±°ë¦¬ ê³µì‹:</strong> <span class="math-formula">r = (|x/Rx|^n + |y/Ry|^n)^(1/n)</span><br>
                <strong>ìŠ¤ë„¬ì˜ ë²•ì¹™:</strong> <span class="math-formula">nâ‚sin(Î¸â‚) = nâ‚‚sin(Î¸â‚‚)</span><br>
                <strong>íŒŒë¼ë¯¸í„°:</strong> Rx,Ry(ë°˜ì§€ë¦„), h(ë†’ì´), n(ìŠˆí¼ì—˜ë¦½ìŠ¤ ì§€ìˆ˜), Î±(ê³¡ë¥ ), ëª¨ë“  ì¹˜ìˆ˜ëŠ” Î¼m ë‹¨ìœ„
            </div>
        </div>
    </div>

    <script>
        let currentView = 'Contour';
        
        // ì„¹ì…˜ í† ê¸€ í•¨ìˆ˜
        function toggleSection(sectionId) {
            const content = document.getElementById(sectionId + '-content');
            const header = content.previousElementSibling;
            
            content.classList.toggle('collapsed');
            header.classList.toggle('collapsed');
        }
        
        // íŒŒë¼ë¯¸í„° ê°’ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateValueDisplay(id, value) {
            let displayValue = value;
            if (id === 'Rx' || id === 'Ry' || id === 'h' || id === 'spacingX' || id === 'spacingY' || id === 'propagationDistance') {
                displayValue = value + ' Î¼m';
            }
            const element = document.getElementById(id + 'Value');
            if (element) {
                element.textContent = displayValue;
            }
        }
        
        // íƒ€ì›í˜• ìŠˆí¼ì—˜ë¦½ìŠ¤ ê±°ë¦¬ ê³„ì‚°
        function superellipseDistance(x, y, Rx, Ry, n) {
            return Math.pow(Math.pow(Math.abs(x / Rx), n) + Math.pow(Math.abs(y / Ry), n), 1/n);
        }
        
        // ë Œì¦ˆ ë†’ì´ ê³„ì‚°
        function lensHeight(r, h, alpha) {
            if (r > 1) return 0;
            return h * Math.pow(1 - r * r, 1 / (2 * alpha));
        }
        
        // ë‹¨ì¼ ë Œì¦ˆ ì„œí”¼ìŠ¤ ìƒì„±
        function mla_surface(Rx, Ry, h, n, alpha, resolution, sizeX, sizeY) {
            const stepX = (2 * sizeX) / resolution;
            const stepY = (2 * sizeY) / resolution;
            const x = [];
            const y = [];
            const z = [];
            
            for (let i = 0; i <= resolution; i++) {
                const xi = -sizeX + i * stepX;
                const row_y = [];
                const row_z = [];
                
                for (let j = 0; j <= resolution; j++) {
                    const yi = -sizeY + j * stepY;
                    const r = superellipseDistance(xi, yi, Rx, Ry, n);
                    
                    let zi = 0;
                    if (r <= 1) {
                        zi = h * Math.pow(1 - r * r, 1 / (2 * alpha));
                    }
                    
                    row_y.push(yi);
                    row_z.push(zi);
                }
                
                x.push(xi);
                y.push(row_y);
                z.push(row_z);
            }
            
            return { x, y, z };
        }
        
        // ë‹¤ì¤‘ ë Œì¦ˆ ë°°ì—´ ë°ì´í„° ìƒì„±
        function generateLensArray(config, Rx, Ry, h, n, alpha, resolution, spacingX, spacingY) {
            const [rows, cols] = config.split('x').map(Number);
            
            // ì „ì²´ ì˜ì—­ í¬ê¸° ê³„ì‚°
            const totalWidth = cols * spacingX;
            const totalHeight = rows * spacingY;
            const maxSizeX = totalWidth / 2;
            const maxSizeY = totalHeight / 2;
            
            const stepX = totalWidth / resolution;
            const stepY = totalHeight / resolution;
            const x = [];
            const y = [];
            const z = [];
            
            for (let i = 0; i <= resolution; i++) {
                const xi = -maxSizeX + i * stepX;
                const row_y = [];
                const row_z = [];
                
                for (let j = 0; j <= resolution; j++) {
                    const yi = -maxSizeY + j * stepY;
                    let maxZ = 0;
                    
                    // ê° ë Œì¦ˆ ìœ„ì¹˜ì—ì„œ ë†’ì´ ê³„ì‚°
                    for (let row = 0; row < rows; row++) {
                        for (let col = 0; col < cols; col++) {
                            const centerX = (col - (cols - 1) / 2) * spacingX;
                            const centerY = (row - (rows - 1) / 2) * spacingY;
                            
                            const relX = xi - centerX;
                            const relY = yi - centerY;
                            
                            const r = superellipseDistance(relX, relY, Rx, Ry, n);
                            
                            let zi = 0;
                            if (r <= 1) {
                                zi = h * Math.pow(1 - r * r, 1 / (2 * alpha));
                            }
                            
                            maxZ = Math.max(maxZ, zi);
                        }
                    }
                    
                    row_y.push(yi);
                    row_z.push(maxZ);
                }
                
                x.push(xi);
                y.push(row_y);
                z.push(row_z);
            }
            
            return { x, y, z };
        }
        
        // ê´‘ì„  ì¶”ì  ê´€ë ¨ í•¨ìˆ˜ë“¤
        
        // ë Œì¦ˆ í‘œë©´ì˜ ë²•ì„  ë²¡í„° ê³„ì‚°
        function calculateSurfaceNormal(x, y, Rx, Ry, h, n, alpha) {
            const r = superellipseDistance(x, y, Rx, Ry, n);
            if (r >= 1) return { nx: 0, ny: 0, nz: 1 }; // í‰ë©´ ì˜ì—­
            
            // ìˆ˜ì¹˜ì  ë¯¸ë¶„ìœ¼ë¡œ ë²•ì„  ê³„ì‚°
            const eps = 0.001;
            const z0 = h * Math.pow(1 - r * r, 1 / (2 * alpha));
            
            const rx = superellipseDistance(x + eps, y, Rx, Ry, n);
            const ry = superellipseDistance(x, y + eps, Rx, Ry, n);
            
            let zx = 0, zy = 0;
            if (rx < 1) zx = h * Math.pow(1 - rx * rx, 1 / (2 * alpha));
            if (ry < 1) zy = h * Math.pow(1 - ry * ry, 1 / (2 * alpha));
            
            const dzdx = (zx - z0) / eps;
            const dzdy = (zy - z0) / eps;
            
            // ë²•ì„  ë²¡í„° ì •ê·œí™”
            const length = Math.sqrt(dzdx * dzdx + dzdy * dzdy + 1);
            return { nx: -dzdx / length, ny: -dzdy / length, nz: 1 / length };
        }
        
        // ìŠ¤ë„¬ì˜ ë²•ì¹™ì„ ì´ìš©í•œ êµ´ì ˆ ê³„ì‚°
        function refractRay(incident, normal, n1, n2) {
            const { dx, dy, dz } = incident;
            const { nx, ny, nz } = normal;
            
            // ì…ì‚¬ê° ê³„ì‚°
            const cosI = -(dx * nx + dy * ny + dz * nz);
            const eta = n1 / n2;
            const k = 1 - eta * eta * (1 - cosI * cosI);
            
            if (k < 0) {
                // ì „ë°˜ì‚¬ - ë°˜ì‚¬ë§Œ ë°œìƒ
                return {
                    dx: dx + 2 * cosI * nx,
                    dy: dy + 2 * cosI * ny,
                    dz: dz + 2 * cosI * nz
                };
            }
            
            const sqrtK = Math.sqrt(k);
            return {
                dx: eta * dx + (eta * cosI - sqrtK) * nx,
                dy: eta * dy + (eta * cosI - sqrtK) * ny,
                dz: eta * dz + (eta * cosI - sqrtK) * nz
            };
        }
        
        // íŠ¹ì • ë Œì¦ˆì™€ ê´‘ì„ ì˜ êµì  ê²€ì¶œ
        function findRayLensIntersection(rayX, rayY, lensCenterX, lensCenterY, Rx, Ry, h, n, alpha) {
            // ë Œì¦ˆ ì¤‘ì‹¬ ê¸°ì¤€ ìƒëŒ€ ì¢Œí‘œ
            const relX = rayX - lensCenterX;
            const relY = rayY - lensCenterY;
            
            // ì´ ë Œì¦ˆ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
            const r = superellipseDistance(relX, relY, Rx, Ry, n);
            if (r > 1) {
                return null; // ì´ ë Œì¦ˆ ë²”ìœ„ ë°–
            }
            
            // ë Œì¦ˆ í‘œë©´ ë†’ì´ ê³„ì‚°
            const lensHeight = h * Math.pow(1 - r * r, 1 / (2 * alpha));
            return {
                x: rayX,
                y: rayY,
                z: lensHeight,
                lensCenter: { x: lensCenterX, y: lensCenterY },
                relativePos: { x: relX, y: relY },
                r: r
            };
        }
        
        // ë°°ì—´ì˜ ëª¨ë“  ë Œì¦ˆì™€ ê´‘ì„ ì˜ êµì  ì°¾ê¸°
        function findAllLensIntersections(rayX, rayY, config, spacingX, spacingY, Rx, Ry, h, n, alpha) {
            const [rows, cols] = config.split('x').map(Number);
            const intersections = [];
            
            for (let lensRow = 0; lensRow < rows; lensRow++) {
                for (let lensCol = 0; lensCol < cols; lensCol++) {
                    const lensCenterX = (lensCol - (cols - 1) / 2) * spacingX;
                    const lensCenterY = (lensRow - (rows - 1) / 2) * spacingY;
                    
                    const intersection = findRayLensIntersection(
                        rayX, rayY, lensCenterX, lensCenterY, Rx, Ry, h, n, alpha
                    );
                    
                    if (intersection) {
                        intersection.lensIndex = { row: lensRow, col: lensCol };
                        intersections.push(intersection);
                    }
                }
            }
            
            // ê°€ì¥ ë†’ì€ êµì  ì„ íƒ (ìœ„ì— ìˆëŠ” ë Œì¦ˆ)
            if (intersections.length === 0) return null;
            
            return intersections.reduce((highest, current) => 
                current.z > highest.z ? current : highest
            );
        }
        
        // ë°°ì—´ì„ ê³ ë ¤í•œ ê´‘ì„  ì¶”ì 
        function traceRayThroughLensArray(startX, startY, config, spacingX, spacingY, Rx, Ry, h, n, alpha, refractiveIndex, propagationDistance) {
            const path = [{ x: startX, y: startY, z: h + 0.5 }]; // ì‹œì‘ì  (ë Œì¦ˆ ìœ„)
            
            // ë Œì¦ˆ ë°°ì—´ê³¼ì˜ êµì  ì°¾ê¸°
            const intersection = findAllLensIntersections(startX, startY, config, spacingX, spacingY, Rx, Ry, h, n, alpha);
            
            if (!intersection) {
                // ì–´ë–¤ ë Œì¦ˆì™€ë„ ë§Œë‚˜ì§€ ì•Šìœ¼ë©´ ì§ì§„
                const endX = startX;
                const endY = startY;
                const endZ = -propagationDistance;
                path.push({ x: endX, y: endY, z: endZ });
				return { path, focused: false, endPoint: { x: endX, y: endY, z: endZ }, lensIndex: null };
            }
            
            // ë Œì¦ˆ í‘œë©´ì— ë„ë‹¬
            path.push(intersection);
            
            // í•´ë‹¹ ë Œì¦ˆì—ì„œì˜ ë²•ì„  ë²¡í„° ê³„ì‚° (ë Œì¦ˆ ì¤‘ì‹¬ ê¸°ì¤€)
            const normal = calculateSurfaceNormal(
                intersection.relativePos.x, 
                intersection.relativePos.y, 
                Rx, Ry, h, n, alpha
            );
            
            // êµ´ì ˆëœ ë°©í–¥ ê³„ì‚°
            const incident = { dx: 0, dy: 0, dz: -1 }; // ìˆ˜ì§ ì…ì‚¬
            const refracted = refractRay(incident, normal, 1.0, refractiveIndex);
            
            // êµ´ì ˆëœ ê´‘ì„ ìœ¼ë¡œ ì „íŒŒ
            const endX = intersection.x + refracted.dx * propagationDistance;
            const endY = intersection.y + refracted.dy * propagationDistance;
            const endZ = intersection.z + refracted.dz * propagationDistance;
            
            path.push({ x: endX, y: endY, z: endZ });
            
            return { 
                path, 
                focused: true, 
                endPoint: { x: endX, y: endY, z: endZ },
                lensIndex: intersection.lensIndex,
                intersection: intersection
            };
        }
        
        // ì§‘ì†ì  ê³„ì‚°
        function calculateFocalPoint(endPoints) {
            if (endPoints.length === 0) return null;
            
            let sumX = 0, sumY = 0, sumZ = 0;
            let count = 0;
            
            endPoints.forEach(point => {
                if (point.focused) {
                    sumX += point.endPoint.x;
                    sumY += point.endPoint.y;
                    sumZ += point.endPoint.z;
                    count++;
                }
            });
            
            if (count === 0) return null;
            
            return {
                x: sumX / count,
                y: sumY / count,
                z: sumZ / count,
                count: count
            };
        }
        
        // ì»¨íˆ¬ì–´ í”Œë¡¯ (4ê°œ ë·° í¬í•¨)
        function plotContour(data, colormap) {
            // ë©”ì¸ í”Œë¡¯ ìˆ¨ê¸°ê³  ë©€í‹°ë·° ë³´ì—¬ì£¼ê¸°
            document.getElementById('plot').parentElement.style.display = 'none';
            document.getElementById('multiViewContainer').style.display = 'block';
            
            // ë‹¨ì¼ ë Œì¦ˆ ë°ì´í„° ìƒì„± (side viewì™€ diagonal viewìš©)
            const Rx = parseFloat(document.getElementById('Rx').value);
            const Ry = parseFloat(document.getElementById('Ry').value);
            const h = parseFloat(document.getElementById('h').value);
            const n = parseFloat(document.getElementById('n').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const resolution = parseInt(document.getElementById('resolution').value);
            const singleLensData = mla_surface(Rx, Ry, h, n, alpha, resolution, Rx * 1.5, Ry * 1.5);
            
            // X ì¢Œí‘œì˜ ìµœëŒ€ê°’ ê³„ì‚°í•˜ì—¬ yì¶• ë²”ìœ„ ì„¤ì •
            const maxX = Math.max(...singleLensData.x.map(Math.abs));
            const yAxisMax = maxX * 2;
            
            // Top View (ì»¨íˆ¬ì–´ ë¼ì¸)
            const topTrace = {
                x: data.x,
                y: data.y[0],
                z: data.z,
                type: 'contour',
                colorscale: colormap,
                showscale: true,
                contours: {
                    showlines: true,
                    coloring: 'lines'
                }
            };
            
            const topLayout = {
                title: 'Top View (ë“±ê³ ì„ )',
                xaxis: { title: 'X (Î¼m)' },
                yaxis: { title: 'Y (Î¼m)', scaleanchor: 'x' },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };
            
            // Side View XZ (y=0 ë‹¨ë©´) - ë‹¨ì¼ ë Œì¦ˆë§Œ
            const centerYIndex = Math.floor(singleLensData.y[0].length / 2);
            const xzTrace = {
                x: singleLensData.x,
                y: singleLensData.z.map(row => row[centerYIndex]),
                type: 'scatter',
                mode: 'lines',
                name: 'ë‹¨ì¼ ë Œì¦ˆ y=0 ë‹¨ë©´',
                line: { color: 'blue', width: 2 }
            };
            
            const xzLayout = {
                title: 'Side View XZ (ë‹¨ì¼ ë Œì¦ˆ, y=0)',
                xaxis: { title: 'X (Î¼m)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Î¼m)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };
            
            // Side View YZ (x=0 ë‹¨ë©´) - ë‹¨ì¼ ë Œì¦ˆë§Œ
            const centerXIndex = Math.floor(singleLensData.x.length / 2);
            const yzTrace = {
                x: singleLensData.y[0],
                y: singleLensData.z[centerXIndex],
                type: 'scatter',
                mode: 'lines',
                name: 'ë‹¨ì¼ ë Œì¦ˆ x=0 ë‹¨ë©´',
                line: { color: 'red', width: 2 }
            };
            
            const yzLayout = {
                title: 'Side View YZ (ë‹¨ì¼ ë Œì¦ˆ, x=0)',
                xaxis: { title: 'Y (Î¼m)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Î¼m)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };
            
            // Diagonal View (x=y ë‹¨ë©´) - ë‹¨ì¼ ë Œì¦ˆë§Œ
            const diagonalX = [];
            const diagonalZ = [];
            const minSize = Math.min(singleLensData.x.length, singleLensData.y[0].length);
            
            for (let i = 0; i < minSize; i++) {
                const xVal = singleLensData.x[i]  * Math.sqrt(2);
                const zVal = singleLensData.z[i][i];
                diagonalX.push(xVal);
                diagonalZ.push(zVal);
            }
            
            const diagTrace = {
                x: diagonalX,
                y: diagonalZ,
                type: 'scatter',
                mode: 'lines',
                name: 'ë‹¨ì¼ ë Œì¦ˆ x=y ë‹¨ë©´',
                line: { color: 'green', width: 2 }
            };
            
            const diagLayout = {
                title: 'Diagonal View (ë‹¨ì¼ ë Œì¦ˆ, x=y)',
                xaxis: { title: 'Y=X (Î¼m)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Î¼m)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };
            
            Plotly.newPlot('topView', [topTrace], topLayout);
            Plotly.newPlot('diagonalView', [diagTrace], diagLayout);
            Plotly.newPlot('sideViewXZ', [xzTrace], xzLayout);
            Plotly.newPlot('sideViewYZ', [yzTrace], yzLayout);
        }
        
        // 2D ë“±ê³ ì„  í”Œë¡¯ (4ê°œ ë·° í¬í•¨)
        function plot2D(data, colormap) {
            // ë©”ì¸ í”Œë¡¯ ìˆ¨ê¸°ê³  ë©€í‹°ë·° ë³´ì—¬ì£¼ê¸°
            document.getElementById('plot').parentElement.style.display = 'none';
            document.getElementById('multiViewContainer').style.display = 'block';
            
            // ë‹¨ì¼ ë Œì¦ˆ ë°ì´í„° ìƒì„± (side viewì™€ diagonal viewìš©)
            const Rx = parseFloat(document.getElementById('Rx').value);
            const Ry = parseFloat(document.getElementById('Ry').value);
            const h = parseFloat(document.getElementById('h').value);
            const n = parseFloat(document.getElementById('n').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const resolution = parseInt(document.getElementById('resolution').value);
            const singleLensData = mla_surface(Rx, Ry, h, n, alpha, resolution, Rx * 1.5, Ry * 1.5);
            
            // X ì¢Œí‘œì˜ ìµœëŒ€ê°’ ê³„ì‚°í•˜ì—¬ yì¶• ë²”ìœ„ ì„¤ì •
            const maxX = Math.max(...singleLensData.x.map(Math.abs));
            const yAxisMax = maxX * 2;
            
            // Top View (ë“±ê³ ì„ )
            const topTrace = {
                x: data.x,
                y: data.y[0],
                z: data.z,
                type: 'contour',
                colorscale: colormap,
                showscale: true,
                contours: {
                    showlines: true,
                    coloring: 'fill'
                }
            };
            
            const topLayout = {
                title: 'Top View (Zì¶• ë“±ê³ ì„ )',
                xaxis: { title: 'X (Î¼m)' },
                yaxis: { title: 'Y (Î¼m)', scaleanchor: 'x' },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };
            
            // Side View XZ (y=0 ë‹¨ë©´) - ë‹¨ì¼ ë Œì¦ˆë§Œ
            const centerYIndex = Math.floor(singleLensData.y[0].length / 2);
            const xzTrace = {
                x: singleLensData.x,
                y: singleLensData.z.map(row => row[centerYIndex]),
                type: 'scatter',
                mode: 'lines',
                name: 'ë‹¨ì¼ ë Œì¦ˆ y=0 ë‹¨ë©´',
                line: { color: 'blue', width: 2 }
            };
            
            const xzLayout = {
                title: 'Side View XZ (ë‹¨ì¼ ë Œì¦ˆ, y=0)',
                xaxis: { title: 'X (Î¼m)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Î¼m)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };
            
            // Side View YZ (x=0 ë‹¨ë©´) - ë‹¨ì¼ ë Œì¦ˆë§Œ
            const centerXIndex = Math.floor(singleLensData.x.length / 2);
            const yzTrace = {
                x: singleLensData.y[0],
                y: singleLensData.z[centerXIndex],
                type: 'scatter',
                mode: 'lines',
                name: 'ë‹¨ì¼ ë Œì¦ˆ x=0 ë‹¨ë©´',
                line: { color: 'red', width: 2 }
            };
            
            const yzLayout = {
                title: 'Side View YZ (ë‹¨ì¼ ë Œì¦ˆ, x=0)',
                xaxis: { title: 'Y (Î¼m)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Î¼m)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };
            
            // Diagonal View (x=y ë‹¨ë©´) - ë‹¨ì¼ ë Œì¦ˆë§Œ
            const diagonalX = [];
            const diagonalZ = [];
            const minSize = Math.min(singleLensData.x.length, singleLensData.y[0].length);
            
            for (let i = 0; i < minSize; i++) {
                const xVal = singleLensData.x[i] * Math.sqrt(2);
                const zVal = singleLensData.z[i][i];
                diagonalX.push(xVal);
                diagonalZ.push(zVal);
            }
            
            const diagTrace = {
                x: diagonalX,
                y: diagonalZ,
                type: 'scatter',
                mode: 'lines',
                name: 'ë‹¨ì¼ ë Œì¦ˆ x=y ë‹¨ë©´',
                line: { color: 'green', width: 2 }
            };
            
            const diagLayout = {
                title: 'Diagonal View (ë‹¨ì¼ ë Œì¦ˆ, x=y)',
                xaxis: { title: 'Y=X (Î¼m)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Î¼m)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };
            
            Plotly.newPlot('topView', [topTrace], topLayout);
            Plotly.newPlot('diagonalView', [diagTrace], diagLayout);
            Plotly.newPlot('sideViewXZ', [xzTrace], xzLayout);
            Plotly.newPlot('sideViewYZ', [yzTrace], yzLayout);
        }
        
        // 3D ì„œí”¼ìŠ¤ í”Œë¡¯
        function plot3D(data, colormap) {
            // ë©€í‹°ë·° ìˆ¨ê¸°ê³  ë©”ì¸ í”Œë¡¯ ë³´ì—¬ì£¼ê¸°
            document.getElementById('multiViewContainer').style.display = 'none';
            document.getElementById('plot').parentElement.style.display = 'block';
            
            // X ì¢Œí‘œì˜ ìµœëŒ€ê°’ ê³„ì‚°
            const maxX = Math.max(...data.x);
            const zMax = maxX * 2;
            
            const trace = {
                x: data.x,
                y: data.y[0],
                z: data.z,
                type: 'surface',
                colorscale: colormap,
                showscale: true,
                colorbar: {
                    title: 'ë†’ì´ (Î¼m)'
                }
            };
            
            const layout = {
                title: '3D ì„œí”¼ìŠ¤ ë·° - ë§ˆì´í¬ë¡œ ë Œì¦ˆ ì–´ë ˆì´',
                scene: {
                    xaxis: { title: 'X ì¢Œí‘œ (Î¼m)' },
                    yaxis: { title: 'Y ì¢Œí‘œ (Î¼m)' },
                    zaxis: { title: 'Z ì¢Œí‘œ (ë†’ì´, Î¼m)' },
                    aspectmode: 'data'
                }
            };
            
            Plotly.newPlot('plot', [trace], layout);
        }
        
        // 2D ê´‘ì„  ì¶”ì  í”Œë¡¯ (Xì¶• ë·°ì™€ Yì¶• ë·°)
        function plotRay2D(data, colormap) {
            document.getElementById('plot').parentElement.style.display = 'none';
            document.getElementById('multiViewContainer').style.display = 'block';
            
            const config = document.getElementById('arrayConfig').value;
            const [rows, cols] = config.split('x').map(Number);
            const Rx = parseFloat(document.getElementById('Rx').value);
            const Ry = parseFloat(document.getElementById('Ry').value);
            const h = parseFloat(document.getElementById('h').value);
            const n = parseFloat(document.getElementById('n').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const numRays = parseInt(document.getElementById('numRays').value);
            const refractiveIndex = parseFloat(document.getElementById('refractiveIndex').value);
            const propagationDistance = parseFloat(document.getElementById('propagationDistance').value);
            const raySpacing = parseFloat(document.getElementById('raySpacing').value);
            const spacingX = parseFloat(document.getElementById('spacingX').value);
            const spacingY = parseFloat(document.getElementById('spacingY').value);
            
            // Xì¶• ë·° (Y=0 ë‹¨ë©´)
            const tracesX = [];
            const endPointsX = [];
            
            // ë Œì¦ˆ í”„ë¡œíŒŒì¼ ê·¸ë¦¬ê¸° (Xì¶• ë·°)
            for (let lensCol = 0; lensCol < cols; lensCol++) {
                const lensCenterX = (lensCol - (cols - 1) / 2) * spacingX;
                const lensX = [];
                const lensZ = [];
                
                for (let x = lensCenterX - Rx * 1.2; x <= lensCenterX + Rx * 1.2; x += 0.05) {
                    const localX = x - lensCenterX;
                    const r = Math.abs(localX / Rx);
                    if (r <= 1) {
                        const z = h * Math.pow(1 - r * r, 1 / (2 * alpha));
                        lensX.push(x);
                        lensZ.push(z);
                    }
                }
                
                tracesX.push({
                    x: lensX,
                    y: lensZ,
                    type: 'scatter',
                    mode: 'lines',
                    name: `ë Œì¦ˆ ${lensCol+1} í”„ë¡œíŒŒì¼`,
                    line: { color: 'black', width: 3 },
                    showlegend: false
                });
            }
            
            // Xì¶• ê´‘ì„  ì¶”ì  - ì „ì²´ ë°°ì—´ ì˜ì—­ì— ê´‘ì„  ë¶„í¬
            const colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'gray'];
            let rayIndex = 0;
            
            const totalWidth = cols * spacingX;
            const rayStep = totalWidth * raySpacing / numRays;
            
            for (let i = 0; i < numRays; i++) {
                const startX = (i - (numRays-1)/2) * rayStep;
                const rayResult = traceRayThroughLensArray(startX, 0, config, spacingX, 0, Rx, Ry, h, n, alpha, refractiveIndex, propagationDistance);
                
                const rayX = rayResult.path.map(p => p.x);
                const rayZ = rayResult.path.map(p => p.z);
                
                tracesX.push({
                    x: rayX,
                    y: rayZ,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: `ê´‘ì„  ${rayIndex+1}`,
                    line: { color: colors[rayIndex % colors.length], width: 2 },
                    marker: { size: 3 },
                    showlegend: false
                });
                
                if (rayResult.focused) {
                    endPointsX.push(rayResult);
                }
                rayIndex++;
            }
            
            // Yì¶• ë·° (X=0 ë‹¨ë©´)
            const tracesY = [];
            const endPointsY = [];
            rayIndex = 0;
            
            // ë Œì¦ˆ í”„ë¡œíŒŒì¼ ê·¸ë¦¬ê¸° (Yì¶• ë·°)
            for (let lensRow = 0; lensRow < rows; lensRow++) {
                const lensCenterY = (lensRow - (rows - 1) / 2) * spacingY;
                const lensY = [];
                const lensZ = [];
                
                for (let y = lensCenterY - Ry * 1.2; y <= lensCenterY + Ry * 1.2; y += 0.05) {
                    const localY = y - lensCenterY;
                    const r = Math.abs(localY / Ry);
                    if (r <= 1) {
                        const z = h * Math.pow(1 - r * r, 1 / (2 * alpha));
                        lensY.push(y);
                        lensZ.push(z);
                    }
                }
                
                tracesY.push({
                    x: lensY,
                    y: lensZ,
                    type: 'scatter',
                    mode: 'lines',
                    name: `ë Œì¦ˆ ${lensRow+1} í”„ë¡œíŒŒì¼`,
                    line: { color: 'black', width: 3 },
                    showlegend: false
                });
            }
            
            // Yì¶• ê´‘ì„  ì¶”ì  - ì „ì²´ ë°°ì—´ ì˜ì—­ì— ê´‘ì„  ë¶„í¬
            const totalHeight = rows * spacingY;
            const rayStepY = totalHeight * raySpacing / numRays;
            
            for (let i = 0; i < numRays; i++) {
                const startY = (i - (numRays-1)/2) * rayStepY;
                const rayResult = traceRayThroughLensArray(0, startY, config, 0, spacingY, Rx, Ry, h, n, alpha, refractiveIndex, propagationDistance);
                
                const rayY = rayResult.path.map(p => p.y);
                const rayZ = rayResult.path.map(p => p.z);
                
                tracesY.push({
                    x: rayY,
                    y: rayZ,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: `ê´‘ì„  ${rayIndex+1}`,
                    line: { color: colors[rayIndex % colors.length], width: 2 },
                    marker: { size: 3 },
                    showlegend: false
                });
                
                if (rayResult.focused) {
                    endPointsY.push(rayResult);
                }
                rayIndex++;
            }
            
            // ì§‘ì†ì  ê³„ì‚°
            const focalPointX = calculateFocalPoint(endPointsX);
            const focalPointY = calculateFocalPoint(endPointsY);
            
            let focalInfoX = "ì§‘ì†ì  ì—†ìŒ";
            let focalInfoY = "ì§‘ì†ì  ì—†ìŒ";
            
            if (focalPointX) {
                focalInfoX = `X: ${focalPointX.x.toFixed(3)}Î¼m, Z: ${focalPointX.z.toFixed(3)}Î¼m (${focalPointX.count}ê°œ ê´‘ì„ )`;
            }
            
            if (focalPointY) {
                focalInfoY = `Y: ${focalPointY.y.toFixed(3)}Î¼m, Z: ${focalPointY.z.toFixed(3)}Î¼m (${focalPointY.count}ê°œ ê´‘ì„ )`;
            }
            
            const layoutX = {
                title: `Xì¶• ë·° (Y=0 ë‹¨ë©´) - ${config} ë°°ì—´<br><span style="font-size:12px">ì§‘ì†ì : ${focalInfoX}</span>`,
                xaxis: { title: 'X ì¢Œí‘œ (Î¼m)' },
                yaxis: { title: 'Z ì¢Œí‘œ (Î¼m)', scaleanchor: 'x' },
                margin: { l: 50, r: 50, t: 80, b: 50 }
            };
            
            const layoutY = {
                title: `Yì¶• ë·° (X=0 ë‹¨ë©´) - ${config} ë°°ì—´<br><span style="font-size:12px">ì§‘ì†ì : ${focalInfoY}</span>`,
                xaxis: { title: 'Y ì¢Œí‘œ (Î¼m)' },
                yaxis: { title: 'Z ì¢Œí‘œ (Î¼m)', scaleanchor: 'x' },
                margin: { l: 50, r: 50, t: 80, b: 50 }
            };
            
            Plotly.newPlot('topView', tracesX, layoutX);
            Plotly.newPlot('diagonalView', tracesY, layoutY);

            // ë‚˜ë¨¸ì§€ ë·°ëŠ” ë¹ˆ í”Œë¡¯ìœ¼ë¡œ ì„¤ì •
            Plotly.newPlot('sideViewXZ', [], { title: '' });            
            Plotly.newPlot('sideViewYZ', [], { title: '' });
        }
        
        // 3D ê´‘ì„  ì¶”ì  í”Œë¡¯ (ë°°ì—´ ê¸°ë°˜ ìˆ˜ì •ëœ ë²„ì „)
        function plotRay3D(data, colormap) {
            document.getElementById('multiViewContainer').style.display = 'none';
            document.getElementById('plot').parentElement.style.display = 'block';
            
            const config = document.getElementById('arrayConfig').value;
            const [rows, cols] = config.split('x').map(Number);
            const Rx = parseFloat(document.getElementById('Rx').value);
            const Ry = parseFloat(document.getElementById('Ry').value);
            const h = parseFloat(document.getElementById('h').value);
            const n = parseFloat(document.getElementById('n').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const numRays = parseInt(document.getElementById('numRays').value);
            const refractiveIndex = parseFloat(document.getElementById('refractiveIndex').value);
            const propagationDistance = parseFloat(document.getElementById('propagationDistance').value);
            const raySpacing = parseFloat(document.getElementById('raySpacing').value);
            const spacingX = parseFloat(document.getElementById('spacingX').value);
            const spacingY = parseFloat(document.getElementById('spacingY').value);
            
            const traces = [];
            const allEndPoints = [];
            
            // ë Œì¦ˆ í‘œë©´ ê·¸ë¦¬ê¸° (ì„ íƒëœ ë°°ì—´ êµ¬ì„±ì— ë§ê²Œ)
            traces.push({
                x: data.x,
                y: data.y[0],
                z: data.z,
                type: 'surface',
                colorscale: 'Greys',
                opacity: 0.7,
                showscale: false,
                name: 'ë Œì¦ˆ í‘œë©´'
            });
            
            // ì „ì²´ ë°°ì—´ ì˜ì—­ì— ê· ë“±í•˜ê²Œ ê´‘ì„  ë¶„í¬
            const colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'yellow', 'cyan', 'magenta'];
            let rayIndex = 0;
            
            const totalWidth = cols * spacingX;
            const totalHeight = rows * spacingY;
            const raysPerSide = Math.ceil(Math.sqrt(numRays));
            
            const rayStepX = totalWidth * raySpacing / (raysPerSide - 1);
            const rayStepY = totalHeight * raySpacing / (raysPerSide - 1);
            
            for (let i = 0; i < raysPerSide; i++) {
                for (let j = 0; j < raysPerSide; j++) {
                    const startX = (i - (raysPerSide-1)/2) * rayStepX;
                    const startY = (j - (raysPerSide-1)/2) * rayStepY;
                    
                    const rayResult = traceRayThroughLensArray(
                        startX, startY, config, spacingX, spacingY, 
                        Rx, Ry, h, n, alpha, refractiveIndex, propagationDistance
                    );
                    
                    const rayX = rayResult.path.map(p => p.x);
                    const rayY = rayResult.path.map(p => p.y);
                    const rayZ = rayResult.path.map(p => p.z);
                    
                    traces.push({
                        x: rayX,
                        y: rayY,
                        z: rayZ,
                        type: 'scatter3d',
                        mode: 'lines+markers',
                        name: `ê´‘ì„  ${rayIndex+1}`,
                        line: { color: colors[rayIndex % colors.length], width: 4 },
                        marker: { size: 2 },
                        showlegend: false
                    });
                    
                    if (rayResult.focused) {
                        allEndPoints.push(rayResult);
                    }
                    
                    rayIndex++;
                    if (rayIndex >= 50) break; // ì„±ëŠ¥ì„ ìœ„í•œ ì œí•œ
                }
                if (rayIndex >= 50) break;
            }
            
            // ì „ì²´ ì§‘ì†ì  ê³„ì‚°
            const globalFocalPoint = calculateFocalPoint(allEndPoints);
            let focalInfo = "ì§‘ì†ì  ì •ë³´ ì—†ìŒ";
            
            if (globalFocalPoint) {
                focalInfo = `ì§‘ì†ì : (${globalFocalPoint.x.toFixed(3)}, ${globalFocalPoint.y.toFixed(3)}, ${globalFocalPoint.z.toFixed(3)}) Î¼m | ${globalFocalPoint.count}ê°œ ê´‘ì„  ì§‘ì†`;
                
                // ì§‘ì†ì ì„ í° ë§ˆì»¤ë¡œ í‘œì‹œ
                traces.push({
                    x: [globalFocalPoint.x],
                    y: [globalFocalPoint.y],
                    z: [globalFocalPoint.z],
                    type: 'scatter3d',
                    mode: 'markers',
                    name: 'ì§‘ì†ì ',
                    marker: { 
                        size: 15, 
                        color: 'red',
                        symbol: 'diamond'
                    },
                    showlegend: true
                });
            }
            
            const layout = {
                title: `3D ê´‘ì„  ì¶”ì  - ${config} ë§ˆì´í¬ë¡œ ë Œì¦ˆ ì–´ë ˆì´<br><span style="font-size:12px">${focalInfo}</span>`,
                scene: {
                    xaxis: { title: 'X (Î¼m)' },
                    yaxis: { title: 'Y (Î¼m)' },
                    zaxis: { title: 'Z (Î¼m)' },
                    aspectmode: 'data'
                },
                showlegend: true
            };
            
            Plotly.newPlot('plot', traces, layout);
        }
        
        // ì„¤ì •ì„ í´ë¦½ë³´ë“œì— ë³µì‚¬
        async function copyConfigurationToClipboard() {
            const config = {
                arrayConfig: document.getElementById('arrayConfig').value,
                spacingX: parseFloat(document.getElementById('spacingX').value),
                spacingY: parseFloat(document.getElementById('spacingY').value),
                Rx: parseFloat(document.getElementById('Rx').value),
                Ry: parseFloat(document.getElementById('Ry').value),
                h: parseFloat(document.getElementById('h').value),
                n: parseFloat(document.getElementById('n').value),
                alpha: parseFloat(document.getElementById('alpha').value),
                resolution: parseInt(document.getElementById('resolution').value),
                colormap: document.getElementById('colormap').value,
                numRays: parseInt(document.getElementById('numRays').value),
                refractiveIndex: parseFloat(document.getElementById('refractiveIndex').value),
                propagationDistance: parseFloat(document.getElementById('propagationDistance').value),
                raySpacing: parseFloat(document.getElementById('raySpacing').value),
                exportDate: new Date().toISOString(),
                version: '2.0'
            };
            
            const configText = JSON.stringify(config, null, 2);
            
            try {
                await navigator.clipboard.writeText(configText);
                
                // í…ìŠ¤íŠ¸ ì˜ì—­ì—ë„ í‘œì‹œ
                document.getElementById('configTextarea').value = configText;
                
                // ì„±ê³µ ë©”ì‹œì§€
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = 'âœ… ë³µì‚¬ë¨!';
                button.style.background = '#27ae60';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 2000);
                
            } catch (err) {
                // í´ë¦½ë³´ë“œ APIê°€ ì§€ì›ë˜ì§€ ì•ŠëŠ” ê²½ìš° í…ìŠ¤íŠ¸ ì˜ì—­ì—ë§Œ í‘œì‹œ
                document.getElementById('configTextarea').value = configText;
                document.getElementById('configTextarea').select();
                alert('ì„¤ì •ì´ í…ìŠ¤íŠ¸ ì˜ì—­ì— í‘œì‹œë˜ì—ˆìŠµë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ë³µì‚¬í•´ì£¼ì„¸ìš”.');
            }
        }
        
        // ì„¤ì • ì ìš©
        function applyConfiguration() {
            const configText = document.getElementById('configTextarea').value.trim();
            
            if (!configText) {
                alert('ì„¤ì • í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            try {
                const config = JSON.parse(configText);
                
                // ì„¤ì • ê°’ ì ìš©
                if (config.arrayConfig) document.getElementById('arrayConfig').value = config.arrayConfig;
                if (config.spacingX !== undefined) {
                    document.getElementById('spacingX').value = config.spacingX;
                    updateValueDisplay('spacingX', config.spacingX);
                }
                if (config.spacingY !== undefined) {
                    document.getElementById('spacingY').value = config.spacingY;
                    updateValueDisplay('spacingY', config.spacingY);
                }
                if (config.Rx !== undefined) {
                    document.getElementById('Rx').value = config.Rx;
                    updateValueDisplay('Rx', config.Rx);
                }
                if (config.Ry !== undefined) {
                    document.getElementById('Ry').value = config.Ry;
                    updateValueDisplay('Ry', config.Ry);
                }
                if (config.h !== undefined) {
                    document.getElementById('h').value = config.h;
                    updateValueDisplay('h', config.h);
                }
                if (config.n !== undefined) {
                    document.getElementById('n').value = config.n;
                    updateValueDisplay('n', config.n);
                }
                if (config.alpha !== undefined) {
                    document.getElementById('alpha').value = config.alpha;
                    updateValueDisplay('alpha', config.alpha);
                }
                if (config.resolution !== undefined) {
                    document.getElementById('resolution').value = config.resolution;
                    updateValueDisplay('resolution', config.resolution);
                }
                if (config.colormap) document.getElementById('colormap').value = config.colormap;
                if (config.numRays !== undefined) {
                    document.getElementById('numRays').value = config.numRays;
                    updateValueDisplay('numRays', config.numRays);
                }
                if (config.refractiveIndex !== undefined) {
                    document.getElementById('refractiveIndex').value = config.refractiveIndex;
                    updateValueDisplay('refractiveIndex', config.refractiveIndex);
                }
                if (config.propagationDistance !== undefined) {
                    document.getElementById('propagationDistance').value = config.propagationDistance;
                    updateValueDisplay('propagationDistance', config.propagationDistance);
                }
                if (config.raySpacing !== undefined) {
                    document.getElementById('raySpacing').value = config.raySpacing;
                    updateValueDisplay('raySpacing', config.raySpacing);
                }
                
                // í”Œë¡¯ ì—…ë°ì´íŠ¸
                updatePlot();
                
                // ì„±ê³µ ë©”ì‹œì§€
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = 'âœ… ì ìš©ë¨!';
                button.style.background = '#27ae60';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 2000);
                
            } catch (error) {
                alert('ì„¤ì • í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤: ' + error.message);
            }
        }
        
        // ê¸°ë³¸ê°’ ë³µì›
        function resetToDefaults() {
            document.getElementById('arrayConfig').value = '1x1';
            document.getElementById('spacingX').value = 1.0;
            document.getElementById('spacingY').value = 1.0;
            document.getElementById('Rx').value = 1.3;
            document.getElementById('Ry').value = 1.3;
            document.getElementById('h').value = 0.5;
            document.getElementById('n').value = 2.0;
            document.getElementById('alpha').value = 1.0;
            document.getElementById('resolution').value = 100;
            document.getElementById('colormap').value = 'Viridis';
            document.getElementById('numRays').value = 20;
            document.getElementById('refractiveIndex').value = 1.5;
            document.getElementById('propagationDistance').value = 10;
            document.getElementById('raySpacing').value = 0.3;
            
            // ê°’ í‘œì‹œ ì—…ë°ì´íŠ¸
            updateValueDisplay('spacingX', 1.0);
            updateValueDisplay('spacingY', 1.0);
            updateValueDisplay('Rx', 1.3);
            updateValueDisplay('Ry', 1.3);
            updateValueDisplay('h', 0.5);
            updateValueDisplay('n', 2.0);
            updateValueDisplay('alpha', 1.0);
            updateValueDisplay('resolution', 100);
            updateValueDisplay('numRays', 20);
            updateValueDisplay('refractiveIndex', 1.5);
            updateValueDisplay('propagationDistance', 10);
            updateValueDisplay('raySpacing', 0.3);
            
            updatePlot();
        }
        
        // ë©”ì¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updatePlot() {
            const config = document.getElementById('arrayConfig').value;
            const Rx = parseFloat(document.getElementById('Rx').value);
            const Ry = parseFloat(document.getElementById('Ry').value);
            const h = parseFloat(document.getElementById('h').value);
            const n = parseFloat(document.getElementById('n').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const resolution = parseInt(document.getElementById('resolution').value);
            const spacingX = parseFloat(document.getElementById('spacingX').value);
            const spacingY = parseFloat(document.getElementById('spacingY').value);
            const colormap = document.getElementById('colormap').value;
            
            const data = generateLensArray(config, Rx, Ry, h, n, alpha, resolution, spacingX, spacingY);
            
            switch (currentView) {
                case 'Contour':
                    plotContour(data, colormap);
                    break;
                case '2D':
                    plot2D(data, colormap);
                    break;
                case '3D':
                    plot3D(data, colormap);
                    break;
                case 'Ray2D':
                    plotRay2D(data, colormap);
                    break;
                case 'Ray3D':
                    plotRay3D(data, colormap);
                    break;
            }
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        document.addEventListener('DOMContentLoaded', function() {
            // ìŠ¬ë¼ì´ë” ì´ë²¤íŠ¸
            ['Rx', 'Ry', 'h', 'n', 'alpha', 'resolution', 'spacingX', 'spacingY', 'numRays', 'refractiveIndex', 'propagationDistance', 'raySpacing'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', function() {
                        updateValueDisplay(id, this.value);
                        updatePlot();
                    });
                    updateValueDisplay(id, element.value);
                }
            });
            
            // ì„ íƒ ë°•ìŠ¤ ì´ë²¤íŠ¸
            ['arrayConfig', 'colormap'].forEach(id => {
                document.getElementById(id).addEventListener('change', updatePlot);
            });
            
            // ë·° ë²„íŠ¼ ì´ë²¤íŠ¸
            document.getElementById('viewContour').addEventListener('click', function() {
                currentView = 'Contour';
                updateViewButtons();
                updatePlot();
            });
            
            document.getElementById('view2D').addEventListener('click', function() {
                currentView = '2D';
                updateViewButtons();
                updatePlot();
            });
            
            document.getElementById('view3D').addEventListener('click', function() {
                currentView = '3D';
                updateViewButtons();
                updatePlot();
            });
            
            document.getElementById('viewRay2D').addEventListener('click', function() {
                currentView = 'Ray2D';
                updateViewButtons();
                updatePlot();
            });
            
            document.getElementById('viewRay3D').addEventListener('click', function() {
                currentView = 'Ray3D';
                updateViewButtons();
                updatePlot();
            });
            
            // ì´ˆê¸° í”Œë¡¯ ìƒì„±
            updatePlot();
        });
        
        function updateViewButtons() {
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            if (currentView === 'Contour') {
                document.getElementById('viewContour').classList.add('active');
            } else if (currentView === '2D') {
                document.getElementById('view2D').classList.add('active');
            } else if (currentView === '3D') {
                document.getElementById('view3D').classList.add('active');
            } else if (currentView === 'Ray2D') {
                document.getElementById('viewRay2D').classList.add('active');
            } else if (currentView === 'Ray3D') {
                document.getElementById('viewRay3D').classList.add('active');
            }
        }
    </script>
</body>
</html>