<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÎßàÏù¥ÌÅ¨Î°ú Î†åÏ¶à Ïñ¥Î†àÏù¥ ÏãúÍ∞ÅÌôî ÎèÑÍµ¨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.16.1/plotly.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #3498db, #9b59b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .controls {
            margin-bottom: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            padding: 10px;
        }
        
        .control-section {
            margin-bottom: 10px;
        }
        
        .control-header {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        .control-header:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .control-header .arrow {
            font-size: 14px;
            transition: transform 0.3s ease;
        }
        
        .control-header.collapsed .arrow {
            transform: rotate(-90deg);
        }
        
        .control-content {
            background: white;
            border-radius: 0 0 10px 10px;
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .control-content.collapsed {
            max-height: 0;
            padding: 0 20px;
        }
        
        .control-item {
            margin-bottom: 15px;
        }
        
        .control-item label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 14px;
        }
        
        .control-item input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }
        
        .control-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
        
        .control-item select, .control-item button {
            width: 100%;
            padding: 8px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            background: white;
            font-size: 14px;
            cursor: pointer;
        }
        
        .control-item select:focus, .control-item button:focus {
            border-color: #3498db;
            outline: none;
        }
        
        .value-display {
            font-size: 12px;
            color: #7f8c8d;
            text-align: right;
        }
        
        .view-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .view-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        
        .view-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .view-btn.active {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }
        
        .plot-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        
        .info-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
        }
        
        .info-panel h3 {
            margin-top: 0;
        }
        
        .formula-compact {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-family: 'Times New Roman', serif;
            line-height: 1.6;
        }
        
        .math-formula {
            font-family: 'Times New Roman', serif;
            font-size: 14px;
            font-style: italic;
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            border-radius: 3px;
            display: inline;
            margin: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¨ ÎßàÏù¥ÌÅ¨Î°ú Î†åÏ¶à Ïñ¥Î†àÏù¥ ÏãúÍ∞ÅÌôî ÎèÑÍµ¨</h1>
        
        <div class="controls">
            <div class="control-section">
                <div class="control-header" onclick="toggleSection('config')">
                    <span>‚öôÔ∏è ÏÑ§Ï†ï Í¥ÄÎ¶¨</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="control-content collapsed" id="config-content">
                    <div class="control-item">
                        <button onclick="resetToDefaults()">üîÑ Í∏∞Î≥∏Í∞í Î≥µÏõê</button>
                        <button onclick="copyConfigurationToClipboard()">üìã ÏÑ§Ï†ï Î≥µÏÇ¨ (Copy)</button>
                    </div>
                    <div class="control-item">
                        <label for="configTextarea">ÏÑ§Ï†ï Î∂ôÏó¨ÎÑ£Í∏∞:</label>
                        <textarea id="configTextarea" rows="15" style="width: 100%; font-family: monospace; font-size: 12px; border: 2px solid #bdc3c7; border-radius: 5px; padding: 8px;" placeholder="Ïó¨Í∏∞Ïóê ÏÑ§Ï†ï JSONÏùÑ Î∂ôÏó¨ÎÑ£ÏúºÏÑ∏Ïöî..."></textarea>
                        <button onclick="applyConfiguration()">‚úÖ ÏÑ§Ï†ï Ï†ÅÏö©</button>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <div class="control-header" onclick="toggleSection('visual')">
                    <span>üé® ÏãúÍ∞ÅÌôî ÏÑ§Ï†ï</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="control-content collapsed" id="visual-content">
                    <div class="control-item">
                        <label for="resolution">Ìï¥ÏÉÅÎèÑ:</label>
                        <input type="range" id="resolution" min="10" max="200" step="10" value="50">
                        <div class="value-display" id="resolutionValue">30</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="colormap">ÏÉâÏÉÅ Îßµ:</label>
                        <select id="colormap">
                            <option value="Viridis">Viridis</option>
                            <option value="Plasma">Plasma</option>
                            <option value="Inferno">Inferno</option>
                            <option value="Magma">Magma</option>
                            <option value="Jet">Jet</option>
                            <option value="Hot">Hot</option>
                            <option value="Cool">Cool</option>
                            <option value="Rainbow">Rainbow</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <div class="control-header" onclick="toggleSection('array')">
                    <span>üî¢ Î∞∞Ïó¥ Íµ¨ÏÑ±</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="control-content" id="array-content">
                    <div class="control-item">
                        <label for="arrayConfig">Î∞∞Ïó¥ Íµ¨ÏÑ±:</label>
                        <select id="arrayConfig">
                            <option value="1x1" selected>1√ó1 (Îã®Ïùº Î†åÏ¶à)</option>
                            <option value="2x1">2√ó1 (ÏÑ∏Î°ú 2Í∞ú)</option>
                            <option value="1x2">1√ó2 (Í∞ÄÎ°ú 2Í∞ú)</option>
                            <option value="2x2">2√ó2 (2√ó2 Î∞∞Ïó¥)</option>
                            <option value="3x3">3√ó3 (3√ó3 Î∞∞Ïó¥)</option>
                            <option value="4x4">4√ó4 (4√ó4 Î∞∞Ïó¥)</option>
                        </select>
                    </div>
                    
                    <div class="control-item">
                        <label for="spacingX">Î†åÏ¶à Í∞ÑÍ≤© X (Œºm):</label>
                        <input type="range" id="spacingX" min="0.1" max="2.0" step="0.01" value="1.0">
                        <div class="value-display" id="spacingXValue">1.0 Œºm</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="spacingY">Î†åÏ¶à Í∞ÑÍ≤© Y (Œºm):</label>
                        <input type="range" id="spacingY" min="0.1" max="2.0" step="0.01" value="1.0">
                        <div class="value-display" id="spacingYValue">1.0 Œºm</div>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <div class="control-header" onclick="toggleSection('lens')">
                    <span>üîç Î†åÏ¶à ÌòïÌÉú ÌååÎùºÎØ∏ÌÑ∞</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="control-content" id="lens-content">
                    <div class="control-item">
                        <label for="Rx">Î∞òÏßÄÎ¶Ñ X (Rx, Œºm):</label>
                        <input type="range" id="Rx" min="0.1" max="3.0" step="0.01" value="0.6">
                        <div class="value-display" id="RxValue">0.6 Œºm</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="Ry">Î∞òÏßÄÎ¶Ñ Y (Ry, Œºm):</label>
                        <input type="range" id="Ry" min="0.1" max="3.0" step="0.01" value="0.6">
                        <div class="value-display" id="RyValue">0.6 Œºm</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="h">ÎÜíÏù¥ (h, Œºm):</label>
                        <input type="range" id="h" min="0.1" max="1.0" step="0.01" value="0.5">
                        <div class="value-display" id="hValue">0.5 Œºm</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="n">ÏäàÌçºÏóòÎ¶ΩÏä§ ÏßÄÏàò (n):</label>
                        <input type="range" id="n" min="1.0" max="5.0" step="0.05" value="2.0">
                        <div class="value-display" id="nValue">2.0</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="alpha">Í≥°Î•† ÌååÎùºÎØ∏ÌÑ∞ (Œ±):</label>
                        <input type="range" id="alpha" min="0.1" max="2.0" step="0.01" value="1.0">
                        <div class="value-display" id="alphaValue">1.0</div>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <div class="control-header" onclick="toggleSection('ray')">
                    <span>üåà Í¥ëÏÑ† Ï∂îÏ†Å ÏÑ§Ï†ï</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="control-content collapsed" id="ray-content">
                    <div class="control-item">
                        <label for="numRays">Í¥ëÏÑ† Ïàò (per Î†åÏ¶à):</label>
                        <input type="range" id="numRays" min="3" max="50" step="5" value="20">
                        <div class="value-display" id="numRaysValue">20</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="refractiveIndex">Íµ¥Ï†àÎ•† (n):</label>
                        <input type="range" id="refractiveIndex" min="1.3" max="1.6" step="0.01" value="1.5">
                        <div class="value-display" id="refractiveIndexValue">1.5</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="propagationDistance">Ï†ÑÌåå Í±∞Î¶¨ (Œºm):</label>
                        <input type="range" id="propagationDistance" min="1" max="80" step="1" value="2">
                        <div class="value-display" id="propagationDistanceValue">2 Œºm</div>
                    </div>
                    
                    <div class="control-item">
                        <label for="raySpacing">Í¥ëÏÑ† Í∞ÑÍ≤©:</label>
                        <input type="range" id="raySpacing" min="0.1" max="1.0" step="0.01" value="0.9">
                        <div class="value-display" id="raySpacingValue">0.9</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="view-controls">
            <button class="view-btn active" id="viewContour">Ïª®Ìà¨Ïñ¥ Î∑∞</button>
            <button class="view-btn" id="view2D">2D Îì±Í≥†ÏÑ† Î∑∞</button>
            <button class="view-btn" id="view3D">3D ÏÑúÌîºÏä§ Î∑∞</button>
            <button class="view-btn" id="viewRay2D">2D Í¥ëÏÑ† Ï∂îÏ†Å</button>
            <button class="view-btn" id="viewRay3D">3D Í¥ëÏÑ† Ï∂îÏ†Å</button>
        </div>
        
        <div class="plot-container">
            <div id="plot" style="width: 100%; height: 600px;"></div>
        </div>
        
        <div class="plot-container" id="multiViewContainer" style="display: none;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; height: 800px;">
                <div id="topView" style="height: 380px;"></div>
                <div id="diagonalView" style="height: 380px;"></div>
                <div id="sideViewXZ" style="height: 380px;"></div>
                <div id="sideViewYZ" style="height: 380px;"></div>
            </div>
        </div>
        
        <div class="info-panel">
            <h3>üìê ÏàòÌïôÏ†Å Î™®Îç∏</h3>
            <div class="formula-compact">
                <strong>ÏäàÌçºÏóòÎ¶ΩÏä§ Î∞©Ï†ïÏãù:</strong> <span class="math-formula">|x/Rx|^n + |y/Ry|^n = 1</span><br>
                <strong>Î†åÏ¶à ÎÜíÏù¥ Î∞©Ï†ïÏãù:</strong> <span class="math-formula">z(r) = h √ó (1 - r¬≤)^(1/(2Œ±))</span><br>
                <strong>Í±∞Î¶¨ Í≥µÏãù:</strong> <span class="math-formula">r = (|x/Rx|^n + |y/Ry|^n)^(1/n)</span><br>
                <strong>Ïä§ÎÑ¨Ïùò Î≤ïÏπô:</strong> <span class="math-formula">n‚ÇÅsin(Œ∏‚ÇÅ) = n‚ÇÇsin(Œ∏‚ÇÇ)</span><br>
                <strong>ÌååÎùºÎØ∏ÌÑ∞:</strong> Rx,Ry(Î∞òÏßÄÎ¶Ñ), h(ÎÜíÏù¥), n(ÏäàÌçºÏóòÎ¶ΩÏä§ ÏßÄÏàò), Œ±(Í≥°Î•†), Î™®Îì† ÏπòÏàòÎäî Œºm Îã®ÏúÑ
            </div>
        </div>
    </div>

    <script>
        let currentView = 'Contour';
        
        // ÏÑπÏÖò ÌÜ†Í∏Ä Ìï®Ïàò
        function toggleSection(sectionId) {
            const content = document.getElementById(sectionId + '-content');
            const header = content.previousElementSibling;
            
            content.classList.toggle('collapsed');
            header.classList.toggle('collapsed');
        }
        
        // ÌååÎùºÎØ∏ÌÑ∞ Í∞í ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
        function updateValueDisplay(id, value) {
            let displayValue = value;
            if (id === 'Rx' || id === 'Ry' || id === 'h' || id === 'spacingX' || id === 'spacingY' || id === 'propagationDistance') {
                displayValue = value + ' Œºm';
            }
            const element = document.getElementById(id + 'Value');
            if (element) {
                element.textContent = displayValue;
            }
        }
        
        // ÌÉÄÏõêÌòï ÏäàÌçºÏóòÎ¶ΩÏä§ Í±∞Î¶¨ Í≥ÑÏÇ∞
        function superellipseDistance(x, y, Rx, Ry, n) {
            return Math.pow(Math.pow(Math.abs(x / Rx), n) + Math.pow(Math.abs(y / Ry), n), 1/n);
        }
        
        // Î†åÏ¶à ÎÜíÏù¥ Í≥ÑÏÇ∞
        function lensHeight(r, h, alpha) {
            if (r > 1) return 0;
            return h * Math.pow(1 - r * r, 1 / (2 * alpha));
        }
        
        // Îã®Ïùº Î†åÏ¶à ÏÑúÌîºÏä§ ÏÉùÏÑ±
        function mla_surface(Rx, Ry, h, n, alpha, resolution, sizeX, sizeY) {
            const stepX = (2 * sizeX) / resolution;
            const stepY = (2 * sizeY) / resolution;
            const x = [];
            const y = [];
            const z = [];
            
            for (let i = 0; i <= resolution; i++) {
                const xi = -sizeX + i * stepX;
                const row_y = [];
                const row_z = [];
                
                for (let j = 0; j <= resolution; j++) {
                    const yi = -sizeY + j * stepY;
                    const r = superellipseDistance(xi, yi, Rx, Ry, n);
                    
                    let zi = 0;
                    if (r <= 1) {
                        zi = h * Math.pow(1 - r * r, 1 / (2 * alpha));
                    }
                    
                    row_y.push(yi);
                    row_z.push(zi);
                }
                
                x.push(xi);
                y.push(row_y);
                z.push(row_z);
            }
            
            return { x, y, z };
        }
        
        // Îã§Ï§ë Î†åÏ¶à Î∞∞Ïó¥ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
        function generateLensArray(config, Rx, Ry, h, n, alpha, resolution, spacingX, spacingY) {
            const [rows, cols] = config.split('x').map(Number);
            
            // Ï†ÑÏ≤¥ ÏòÅÏó≠ ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
            const totalWidth = cols * spacingX;
            const totalHeight = rows * spacingY;
            const maxSizeX = totalWidth / 2;
            const maxSizeY = totalHeight / 2;
            
            const stepX = totalWidth / resolution;
            const stepY = totalHeight / resolution;
            const x = [];
            const y = [];
            const z = [];
            
            for (let i = 0; i <= resolution; i++) {
                const xi = -maxSizeX + i * stepX;
                const row_y = [];
                const row_z = [];
                
                for (let j = 0; j <= resolution; j++) {
                    const yi = -maxSizeY + j * stepY;
                    let maxZ = 0;
                    
                    // Í∞Å Î†åÏ¶à ÏúÑÏπòÏóêÏÑú ÎÜíÏù¥ Í≥ÑÏÇ∞
                    for (let row = 0; row < rows; row++) {
                        for (let col = 0; col < cols; col++) {
                            const centerX = (col - (cols - 1) / 2) * spacingX;
                            const centerY = (row - (rows - 1) / 2) * spacingY;
                            
                            const relX = xi - centerX;
                            const relY = yi - centerY;
                            
                            const r = superellipseDistance(relX, relY, Rx, Ry, n);
                            
                            let zi = 0;
                            if (r <= 1) {
                                zi = h * Math.pow(1 - r * r, 1 / (2 * alpha));
                            }
                            
                            maxZ = Math.max(maxZ, zi);
                        }
                    }
                    
                    row_y.push(yi);
                    row_z.push(maxZ);
                }
                
                x.push(xi);
                y.push(row_y);
                z.push(row_z);
            }
            
            return { x, y, z };
        }
        
        // Í¥ëÏÑ† Ï∂îÏ†Å Í¥ÄÎ†® Ìï®ÏàòÎì§
        
        // Î†åÏ¶à ÌëúÎ©¥Ïùò Î≤ïÏÑ† Î≤°ÌÑ∞ Í≥ÑÏÇ∞
        function calculateSurfaceNormal(x, y, Rx, Ry, h, n, alpha) {
            const r = superellipseDistance(x, y, Rx, Ry, n);
            if (r >= 1) return { nx: 0, ny: 0, nz: 1 }; // ÌèâÎ©¥ ÏòÅÏó≠
            
            // ÏàòÏπòÏ†Å ÎØ∏Î∂ÑÏúºÎ°ú Î≤ïÏÑ† Í≥ÑÏÇ∞
            const eps = 0.001;
            const z0 = h * Math.pow(1 - r * r, 1 / (2 * alpha));
            
            const rx = superellipseDistance(x + eps, y, Rx, Ry, n);
            const ry = superellipseDistance(x, y + eps, Rx, Ry, n);
            
            let zx = 0, zy = 0;
            if (rx < 1) zx = h * Math.pow(1 - rx * rx, 1 / (2 * alpha));
            if (ry < 1) zy = h * Math.pow(1 - ry * ry, 1 / (2 * alpha));
            
            const dzdx = (zx - z0) / eps;
            const dzdy = (zy - z0) / eps;
            
            // Î≤ïÏÑ† Î≤°ÌÑ∞ Ï†ïÍ∑úÌôî
            const length = Math.sqrt(dzdx * dzdx + dzdy * dzdy + 1);
            return { nx: -dzdx / length, ny: -dzdy / length, nz: 1 / length };
        }
        
        // Ïä§ÎÑ¨Ïùò Î≤ïÏπôÏùÑ Ïù¥Ïö©Ìïú Íµ¥Ï†à Í≥ÑÏÇ∞
        function refractRay(incident, normal, n1, n2) {
            const { dx, dy, dz } = incident;
            const { nx, ny, nz } = normal;
            
            // ÏûÖÏÇ¨Í∞Å Í≥ÑÏÇ∞
            const cosI = -(dx * nx + dy * ny + dz * nz);
            const eta = n1 / n2;
            const k = 1 - eta * eta * (1 - cosI * cosI);
            
            if (k < 0) {
                // Ï†ÑÎ∞òÏÇ¨ - Î∞òÏÇ¨Îßå Î∞úÏÉù
                return {
                    dx: dx + 2 * cosI * nx,
                    dy: dy + 2 * cosI * ny,
                    dz: dz + 2 * cosI * nz
                };
            }
            
            const sqrtK = Math.sqrt(k);
            return {
                dx: eta * dx + (eta * cosI - sqrtK) * nx,
                dy: eta * dy + (eta * cosI - sqrtK) * ny,
                dz: eta * dz + (eta * cosI - sqrtK) * nz
            };
        }
        
        // ÌäπÏ†ï Î†åÏ¶àÏôÄ Í¥ëÏÑ†Ïùò ÍµêÏ†ê Í≤ÄÏ∂ú
        function findRayLensIntersection(rayX, rayY, lensCenterX, lensCenterY, Rx, Ry, h, n, alpha) {
            // Î†åÏ¶à Ï§ëÏã¨ Í∏∞Ï§Ä ÏÉÅÎåÄ Ï¢åÌëú
            const relX = rayX - lensCenterX;
            const relY = rayY - lensCenterY;
            
            // Ïù¥ Î†åÏ¶à Î≤îÏúÑ ÎÇ¥Ïóê ÏûàÎäîÏßÄ ÌôïÏù∏
            const r = superellipseDistance(relX, relY, Rx, Ry, n);
            if (r > 1) {
                return null; // Ïù¥ Î†åÏ¶à Î≤îÏúÑ Î∞ñ
            }
            
            // Î†åÏ¶à ÌëúÎ©¥ ÎÜíÏù¥ Í≥ÑÏÇ∞
            const lensHeight = h * Math.pow(1 - r * r, 1 / (2 * alpha));
            return {
                x: rayX,
                y: rayY,
                z: lensHeight,
                lensCenter: { x: lensCenterX, y: lensCenterY },
                relativePos: { x: relX, y: relY },
                r: r
            };
        }
        
        // Î∞∞Ïó¥Ïùò Î™®Îì† Î†åÏ¶àÏôÄ Í¥ëÏÑ†Ïùò ÍµêÏ†ê Ï∞æÍ∏∞
        function findAllLensIntersections(rayX, rayY, config, spacingX, spacingY, Rx, Ry, h, n, alpha) {
            const [rows, cols] = config.split('x').map(Number);
            const intersections = [];
            
            for (let lensRow = 0; lensRow < rows; lensRow++) {
                for (let lensCol = 0; lensCol < cols; lensCol++) {
                    const lensCenterX = (lensCol - (cols - 1) / 2) * spacingX;
                    const lensCenterY = (lensRow - (rows - 1) / 2) * spacingY;
                    
                    const intersection = findRayLensIntersection(
                        rayX, rayY, lensCenterX, lensCenterY, Rx, Ry, h, n, alpha
                    );
                    
                    if (intersection) {
                        intersection.lensIndex = { row: lensRow, col: lensCol };
                        intersections.push(intersection);
                    }
                }
            }
            
            // Í∞ÄÏû• ÎÜíÏùÄ ÍµêÏ†ê ÏÑ†ÌÉù (ÏúÑÏóê ÏûàÎäî Î†åÏ¶à)
            if (intersections.length === 0) return null;
            
            return intersections.reduce((highest, current) => 
                current.z > highest.z ? current : highest
            );
        }
        
        // Î∞∞Ïó¥ÏùÑ Í≥†Î†§Ìïú Í¥ëÏÑ† Ï∂îÏ†Å
        function traceRayThroughLensArray(startX, startY, config, spacingX, spacingY, Rx, Ry, h, n, alpha, refractiveIndex, propagationDistance) {
            const path = [{ x: startX, y: startY, z: h + 0.5 }]; // ÏãúÏûëÏ†ê (Î†åÏ¶à ÏúÑ)
            
            // Î†åÏ¶à Î∞∞Ïó¥Í≥ºÏùò ÍµêÏ†ê Ï∞æÍ∏∞
            const intersection = findAllLensIntersections(startX, startY, config, spacingX, spacingY, Rx, Ry, h, n, alpha);
            
            if (!intersection) {
                // Ïñ¥Îñ§ Î†åÏ¶àÏôÄÎèÑ ÎßåÎÇòÏßÄ ÏïäÏúºÎ©¥ ÏßÅÏßÑ
                const endX = startX;
                const endY = startY;
                const endZ = -propagationDistance;
                path.push({ x: endX, y: endY, z: endZ });
				return { path, focused: false, endPoint: { x: endX, y: endY, z: endZ }, lensIndex: null };
            }
            
            // Î†åÏ¶à ÌëúÎ©¥Ïóê ÎèÑÎã¨
            path.push(intersection);
            
            // Ìï¥Îãπ Î†åÏ¶àÏóêÏÑúÏùò Î≤ïÏÑ† Î≤°ÌÑ∞ Í≥ÑÏÇ∞ (Î†åÏ¶à Ï§ëÏã¨ Í∏∞Ï§Ä)
            const normal = calculateSurfaceNormal(
                intersection.relativePos.x, 
                intersection.relativePos.y, 
                Rx, Ry, h, n, alpha
            );
            
            // Íµ¥Ï†àÎêú Î∞©Ìñ• Í≥ÑÏÇ∞
            const incident = { dx: 0, dy: 0, dz: -1 }; // ÏàòÏßÅ ÏûÖÏÇ¨
            const refracted = refractRay(incident, normal, 1.0, refractiveIndex);
            
            // Íµ¥Ï†àÎêú Í¥ëÏÑ†ÏúºÎ°ú Ï†ÑÌåå
            const endX = intersection.x + refracted.dx * propagationDistance;
            const endY = intersection.y + refracted.dy * propagationDistance;
            const endZ = intersection.z + refracted.dz * propagationDistance;
            
            path.push({ x: endX, y: endY, z: endZ });
            
            return { 
                path, 
                focused: true, 
                endPoint: { x: endX, y: endY, z: endZ },
                lensIndex: intersection.lensIndex,
                intersection: intersection
            };
        }
        
        // ÏßëÏÜçÏ†ê Í≥ÑÏÇ∞
        function calculateFocalPoint(endPoints) {
            if (endPoints.length === 0) return null;
            
            let sumX = 0, sumY = 0, sumZ = 0;
            let count = 0;
            
            endPoints.forEach(point => {
                if (point.focused) {
                    sumX += point.endPoint.x;
                    sumY += point.endPoint.y;
                    sumZ += point.endPoint.z;
                    count++;
                }
            });
            
            if (count === 0) return null;
            
            return {
                x: sumX / count,
                y: sumY / count,
                z: sumZ / count,
                count: count
            };
        }
        
        // Ïª®Ìà¨Ïñ¥ ÌîåÎ°Ø (4Í∞ú Î∑∞ Ìè¨Ìï®)
        function plotContour(data, colormap) {
            // Î©îÏù∏ ÌîåÎ°Ø Ïà®Í∏∞Í≥† Î©ÄÌã∞Î∑∞ Î≥¥Ïó¨Ï£ºÍ∏∞
            document.getElementById('plot').parentElement.style.display = 'none';
            document.getElementById('multiViewContainer').style.display = 'block';
            
            // Îã®Ïùº Î†åÏ¶à Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± (side viewÏôÄ diagonal viewÏö©)
            const Rx = parseFloat(document.getElementById('Rx').value);
            const Ry = parseFloat(document.getElementById('Ry').value);
            const h = parseFloat(document.getElementById('h').value);
            const n = parseFloat(document.getElementById('n').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const resolution = parseInt(document.getElementById('resolution').value);
            const singleLensData = mla_surface(Rx, Ry, h, n, alpha, resolution, Rx * 1.5, Ry * 1.5);
            
            // X Ï¢åÌëúÏùò ÏµúÎåÄÍ∞í Í≥ÑÏÇ∞ÌïòÏó¨ yÏ∂ï Î≤îÏúÑ ÏÑ§Ï†ï
            const maxX = Math.max(...singleLensData.x.map(Math.abs));
            const yAxisMax = maxX * 2;
            
            // Top View (Ïª®Ìà¨Ïñ¥ ÎùºÏù∏)
            const topTrace = {
                x: data.x,
                y: data.y[0],
                z: data.z,
                type: 'contour',
                colorscale: colormap,
                showscale: true,
                contours: {
                    showlines: true,
                    coloring: 'lines'
                }
            };
            
            const topLayout = {
                title: 'Top View (Îì±Í≥†ÏÑ†)',
                xaxis: { title: 'X (Œºm)' },
                yaxis: { title: 'Y (Œºm)', scaleanchor: 'x' },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };
            
            // Side View XZ (y=0 Îã®Î©¥) - Îã®Ïùº Î†åÏ¶àÎßå
            const centerYIndex = Math.floor(singleLensData.y[0].length / 2);
            const xzTrace = {
                x: singleLensData.x,
                y: singleLensData.z.map(row => row[centerYIndex]),
                type: 'scatter',
                mode: 'lines',
                name: 'Îã®Ïùº Î†åÏ¶à y=0 Îã®Î©¥',
                line: { color: 'blue', width: 2 }
            };
            
            const xzLayout = {
                title: 'Side View XZ (Îã®Ïùº Î†åÏ¶à, y=0)',
                xaxis: { title: 'X (Œºm)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Œºm)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };
            
            // Side View YZ (x=0 Îã®Î©¥) - Îã®Ïùº Î†åÏ¶àÎßå
            const centerXIndex = Math.floor(singleLensData.x.length / 2);
            const yzTrace = {
                x: singleLensData.y[0],
                y: singleLensData.z[centerXIndex],
                type: 'scatter',
                mode: 'lines',
                name: 'Îã®Ïùº Î†åÏ¶à x=0 Îã®Î©¥',
                line: { color: 'red', width: 2 }
            };
            
            const yzLayout = {
                title: 'Side View YZ (Îã®Ïùº Î†åÏ¶à, x=0)',
                xaxis: { title: 'Y (Œºm)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Œºm)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };
            
            // Diagonal View (x=y Îã®Î©¥) - Îã®Ïùº Î†åÏ¶àÎßå
            const diagonalX = [];
            const diagonalZ = [];
            const minSize = Math.min(singleLensData.x.length, singleLensData.y[0].length);
            
            for (let i = 0; i < minSize; i++) {
                const xVal = singleLensData.x[i]  * Math.sqrt(2);
                const zVal = singleLensData.z[i][i];
                diagonalX.push(xVal);
                diagonalZ.push(zVal);
            }
            
            const diagTrace = {
                x: diagonalX,
                y: diagonalZ,
                type: 'scatter',
                mode: 'lines',
                name: 'Îã®Ïùº Î†åÏ¶à x=y Îã®Î©¥',
                line: { color: 'green', width: 2 }
            };
            
            const diagLayout = {
                title: 'Diagonal View (Îã®Ïùº Î†åÏ¶à, x=y)',
                xaxis: { title: 'Y=X (Œºm)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Œºm)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };
            
            Plotly.newPlot('topView', [topTrace], topLayout);
            Plotly.newPlot('diagonalView', [diagTrace], diagLayout);
            Plotly.newPlot('sideViewXZ', [xzTrace], xzLayout);
            Plotly.newPlot('sideViewYZ', [yzTrace], yzLayout);
        }
        
        // 2D Îì±Í≥†ÏÑ† ÌîåÎ°Ø (4Í∞ú Î∑∞ Ìè¨Ìï®)
        function plot2D(data, colormap) {
            // Î©îÏù∏ ÌîåÎ°Ø Ïà®Í∏∞Í≥† Î©ÄÌã∞Î∑∞ Î≥¥Ïó¨Ï£ºÍ∏∞
            document.getElementById('plot').parentElement.style.display = 'none';
            document.getElementById('multiViewContainer').style.display = 'block';
            
            // Îã®Ïùº Î†åÏ¶à Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± (side viewÏôÄ diagonal viewÏö©)
            const Rx = parseFloat(document.getElementById('Rx').value);
            const Ry = parseFloat(document.getElementById('Ry').value);
            const h = parseFloat(document.getElementById('h').value);
            const n = parseFloat(document.getElementById('n').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const resolution = parseInt(document.getElementById('resolution').value);
            const singleLensData = mla_surface(Rx, Ry, h, n, alpha, resolution, Rx * 1.5, Ry * 1.5);
            
            // X Ï¢åÌëúÏùò ÏµúÎåÄÍ∞í Í≥ÑÏÇ∞ÌïòÏó¨ yÏ∂ï Î≤îÏúÑ ÏÑ§Ï†ï
            const maxX = Math.max(...singleLensData.x.map(Math.abs));
            const yAxisMax = maxX * 2;
            
            // Top View (Îì±Í≥†ÏÑ†)
            const topTrace = {
                x: data.x,
                y: data.y[0],
                z: data.z,
                type: 'contour',
                colorscale: colormap,
                showscale: true,
                contours: {
                    showlines: true,
                    coloring: 'fill'
                }
            };
            
            const topLayout = {
                title: 'Top View (ZÏ∂ï Îì±Í≥†ÏÑ†)',
                xaxis: { title: 'X (Œºm)' },
                yaxis: { title: 'Y (Œºm)', scaleanchor: 'x' },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };
            
            // Side View XZ (y=0 Îã®Î©¥) - Îã®Ïùº Î†åÏ¶àÎßå
            const centerYIndex = Math.floor(singleLensData.y[0].length / 2);
            const xzTrace = {
                x: singleLensData.x,
                y: singleLensData.z.map(row => row[centerYIndex]),
                type: 'scatter',
                mode: 'lines',
                name: 'Îã®Ïùº Î†åÏ¶à y=0 Îã®Î©¥',
                line: { color: 'blue', width: 2 }
            };
            
            const xzLayout = {
                title: 'Side View XZ (Îã®Ïùº Î†åÏ¶à, y=0)',
                xaxis: { title: 'X (Œºm)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Œºm)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };
            
            // Side View YZ (x=0 Îã®Î©¥) - Îã®Ïùº Î†åÏ¶àÎßå
            const centerXIndex = Math.floor(singleLensData.x.length / 2);
            const yzTrace = {
                x: singleLensData.y[0],
                y: singleLensData.z[centerXIndex],
                type: 'scatter',
                mode: 'lines',
                name: 'Îã®Ïùº Î†åÏ¶à x=0 Îã®Î©¥',
                line: { color: 'red', width: 2 }
            };
            
            const yzLayout = {
                title: 'Side View YZ (Îã®Ïùº Î†åÏ¶à, x=0)',
                xaxis: { title: 'Y (Œºm)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Œºm)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };
            
            // Diagonal View (x=y Îã®Î©¥) - Îã®Ïùº Î†åÏ¶àÎßå
            const diagonalX = [];
            const diagonalZ = [];
            const minSize = Math.min(singleLensData.x.length, singleLensData.y[0].length);
            
            for (let i = 0; i < minSize; i++) {
                const xVal = singleLensData.x[i] * Math.sqrt(2);
                const zVal = singleLensData.z[i][i];
                diagonalX.push(xVal);
                diagonalZ.push(zVal);
            }
            
            const diagTrace = {
                x: diagonalX,
                y: diagonalZ,
                type: 'scatter',
                mode: 'lines',
                name: 'Îã®Ïùº Î†åÏ¶à x=y Îã®Î©¥',
                line: { color: 'green', width: 2 }
            };
            
            const diagLayout = {
                title: 'Diagonal View (Îã®Ïùº Î†åÏ¶à, x=y)',
                xaxis: { title: 'Y=X (Œºm)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Œºm)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };
            
            Plotly.newPlot('topView', [topTrace], topLayout);
            Plotly.newPlot('diagonalView', [diagTrace], diagLayout);
            Plotly.newPlot('sideViewXZ', [xzTrace], xzLayout);
            Plotly.newPlot('sideViewYZ', [yzTrace], yzLayout);
        }
        
        // 3D ÏÑúÌîºÏä§ ÌîåÎ°Ø
        function plot3D(data, colormap) {
            // Î©ÄÌã∞Î∑∞ Ïà®Í∏∞Í≥† Î©îÏù∏ ÌîåÎ°Ø Î≥¥Ïó¨Ï£ºÍ∏∞
            document.getElementById('multiViewContainer').style.display = 'none';
            document.getElementById('plot').parentElement.style.display = 'block';
            
            // X Ï¢åÌëúÏùò ÏµúÎåÄÍ∞í Í≥ÑÏÇ∞
            const maxX = Math.max(...data.x);
            const zMax = maxX * 2;
            
            const trace = {
                x: data.x,
                y: data.y[0],
                z: data.z,
                type: 'surface',
                colorscale: colormap,
                showscale: true,
                colorbar: {
                    title: 'ÎÜíÏù¥ (Œºm)'
                }
            };
            
            const layout = {
                title: '3D ÏÑúÌîºÏä§ Î∑∞ - ÎßàÏù¥ÌÅ¨Î°ú Î†åÏ¶à Ïñ¥Î†àÏù¥',
                scene: {
                    xaxis: { title: 'X Ï¢åÌëú (Œºm)' },
                    yaxis: { title: 'Y Ï¢åÌëú (Œºm)' },
                    zaxis: { title: 'Z Ï¢åÌëú (ÎÜíÏù¥, Œºm)' },
                    aspectmode: 'data'
                }
            };
            
            Plotly.newPlot('plot', [trace], layout);
        }
        
        // 2D Í¥ëÏÑ† Ï∂îÏ†Å ÌîåÎ°Ø (XÏ∂ï Î∑∞ÏôÄ YÏ∂ï Î∑∞)
        function plotRay2D(data, colormap) {
            document.getElementById('plot').parentElement.style.display = 'none';
            document.getElementById('multiViewContainer').style.display = 'block';
            
            const config = document.getElementById('arrayConfig').value;
            const [rows, cols] = config.split('x').map(Number);
            const Rx = parseFloat(document.getElementById('Rx').value);
            const Ry = parseFloat(document.getElementById('Ry').value);
            const h = parseFloat(document.getElementById('h').value);
            const n = parseFloat(document.getElementById('n').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const numRays = parseInt(document.getElementById('numRays').value);
            const refractiveIndex = parseFloat(document.getElementById('refractiveIndex').value);
            const propagationDistance = parseFloat(document.getElementById('propagationDistance').value);
            const raySpacing = parseFloat(document.getElementById('raySpacing').value);
            const spacingX = parseFloat(document.getElementById('spacingX').value);
            const spacingY = parseFloat(document.getElementById('spacingY').value);
            
            // XÏ∂ï Î∑∞ (Y=0 Îã®Î©¥)
            const tracesX = [];
            const endPointsX = [];
            
            // Î†åÏ¶à ÌîÑÎ°úÌååÏùº Í∑∏Î¶¨Í∏∞ (XÏ∂ï Î∑∞)
            for (let lensCol = 0; lensCol < cols; lensCol++) {
                const lensCenterX = (lensCol - (cols - 1) / 2) * spacingX;
                const lensX = [];
                const lensZ = [];
                
                for (let x = lensCenterX - Rx * 1.2; x <= lensCenterX + Rx * 1.2; x += 0.05) {
                    const localX = x - lensCenterX;
                    const r = Math.abs(localX / Rx);
                    if (r <= 1) {
                        const z = h * Math.pow(1 - r * r, 1 / (2 * alpha));
                        lensX.push(x);
                        lensZ.push(z);
                    }
                }
                
                tracesX.push({
                    x: lensX,
                    y: lensZ,
                    type: 'scatter',
                    mode: 'lines',
                    name: `Î†åÏ¶à ${lensCol+1} ÌîÑÎ°úÌååÏùº`,
                    line: { color: 'black', width: 3 },
                    showlegend: false
                });
            }
            
            // XÏ∂ï Í¥ëÏÑ† Ï∂îÏ†Å - Ï†ÑÏ≤¥ Î∞∞Ïó¥ ÏòÅÏó≠Ïóê Í¥ëÏÑ† Î∂ÑÌè¨
            const colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'gray'];
            let rayIndex = 0;
            
            const totalWidth = cols * spacingX;
            const rayStep = totalWidth * raySpacing / numRays;
            
            for (let i = 0; i < numRays; i++) {
                const startX = (i - (numRays-1)/2) * rayStep;
                const rayResult = traceRayThroughLensArray(startX, 0, config, spacingX, 0, Rx, Ry, h, n, alpha, refractiveIndex, propagationDistance);
                
                const rayX = rayResult.path.map(p => p.x);
                const rayZ = rayResult.path.map(p => p.z);
                
                tracesX.push({
                    x: rayX,
                    y: rayZ,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: `Í¥ëÏÑ† ${rayIndex+1}`,
                    line: { color: colors[rayIndex % colors.length], width: 2 },
                    marker: { size: 3 },
                    showlegend: false
                });
                
                if (rayResult.focused) {
                    endPointsX.push(rayResult);
                }
                rayIndex++;
            }
            
            // YÏ∂ï Î∑∞ (X=0 Îã®Î©¥)
            const tracesY = [];
            const endPointsY = [];
            rayIndex = 0;
            
            // Î†åÏ¶à ÌîÑÎ°úÌååÏùº Í∑∏Î¶¨Í∏∞ (YÏ∂ï Î∑∞)
            for (let lensRow = 0; lensRow < rows; lensRow++) {
                const lensCenterY = (lensRow - (rows - 1) / 2) * spacingY;
                const lensY = [];
                const lensZ = [];
                
                for (let y = lensCenterY - Ry * 1.2; y <= lensCenterY + Ry * 1.2; y += 0.05) {
                    const localY = y - lensCenterY;
                    const r = Math.abs(localY / Ry);
                    if (r <= 1) {
                        const z = h * Math.pow(1 - r * r, 1 / (2 * alpha));
                        lensY.push(y);
                        lensZ.push(z);
                    }
                }
                
                tracesY.push({
                    x: lensY,
                    y: lensZ,
                    type: 'scatter',
                    mode: 'lines',
                    name: `Î†åÏ¶à ${lensRow+1} ÌîÑÎ°úÌååÏùº`,
                    line: { color: 'black', width: 3 },
                    showlegend: false
                });
            }
            
            // YÏ∂ï Í¥ëÏÑ† Ï∂îÏ†Å - Ï†ÑÏ≤¥ Î∞∞Ïó¥ ÏòÅÏó≠Ïóê Í¥ëÏÑ† Î∂ÑÌè¨
            const totalHeight = rows * spacingY;
            const rayStepY = totalHeight * raySpacing / numRays;
            
            for (let i = 0; i < numRays; i++) {
                const startY = (i - (numRays-1)/2) * rayStepY;
                const rayResult = traceRayThroughLensArray(0, startY, config, 0, spacingY, Rx, Ry, h, n, alpha, refractiveIndex, propagationDistance);
                
                const rayY = rayResult.path.map(p => p.y);
                const rayZ = rayResult.path.map(p => p.z);
                
                tracesY.push({
                    x: rayY,
                    y: rayZ,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: `Í¥ëÏÑ† ${rayIndex+1}`,
                    line: { color: colors[rayIndex % colors.length], width: 2 },
                    marker: { size: 3 },
                    showlegend: false
                });
                
                if (rayResult.focused) {
                    endPointsY.push(rayResult);
                }
                rayIndex++;
            }
            
            // ÏßëÏÜçÏ†ê Í≥ÑÏÇ∞
            const focalPointX = calculateFocalPoint(endPointsX);
            const focalPointY = calculateFocalPoint(endPointsY);
            
            let focalInfoX = "ÏßëÏÜçÏ†ê ÏóÜÏùå";
            let focalInfoY = "ÏßëÏÜçÏ†ê ÏóÜÏùå";
            
            if (focalPointX) {
                focalInfoX = `X: ${focalPointX.x.toFixed(3)}Œºm, Z: ${focalPointX.z.toFixed(3)}Œºm (${focalPointX.count}Í∞ú Í¥ëÏÑ†)`;
            }
            
            if (focalPointY) {
                focalInfoY = `Y: ${focalPointY.y.toFixed(3)}Œºm, Z: ${focalPointY.z.toFixed(3)}Œºm (${focalPointY.count}Í∞ú Í¥ëÏÑ†)`;
            }
            
            const layoutX = {
                title: `XÏ∂ï Î∑∞ (Y=0 Îã®Î©¥) - ${config} Î∞∞Ïó¥<br><span style="font-size:12px">ÏßëÏÜçÏ†ê: ${focalInfoX}</span>`,
                xaxis: { title: 'X Ï¢åÌëú (Œºm)' },
                yaxis: { title: 'Z Ï¢åÌëú (Œºm)', scaleanchor: 'x' },
                margin: { l: 50, r: 50, t: 80, b: 50 }
            };
            
            const layoutY = {
                title: `YÏ∂ï Î∑∞ (X=0 Îã®Î©¥) - ${config} Î∞∞Ïó¥<br><span style="font-size:12px">ÏßëÏÜçÏ†ê: ${focalInfoY}</span>`,
                xaxis: { title: 'Y Ï¢åÌëú (Œºm)' },
                yaxis: { title: 'Z Ï¢åÌëú (Œºm)', scaleanchor: 'x' },
                margin: { l: 50, r: 50, t: 80, b: 50 }
            };
            
            Plotly.newPlot('topView', tracesX, layoutX);
            Plotly.newPlot('diagonalView', tracesY, layoutY);

            // ÎÇòÎ®∏ÏßÄ Î∑∞Îäî Îπà ÌîåÎ°ØÏúºÎ°ú ÏÑ§Ï†ï
            Plotly.newPlot('sideViewXZ', [], { title: '' });            
            Plotly.newPlot('sideViewYZ', [], { title: '' });
        }
        
        // 3D Í¥ëÏÑ† Ï∂îÏ†Å ÌîåÎ°Ø (Î∞∞Ïó¥ Í∏∞Î∞ò ÏàòÏ†ïÎêú Î≤ÑÏ†Ñ)
        function plotRay3D(data, colormap) {
            document.getElementById('multiViewContainer').style.display = 'none';
            document.getElementById('plot').parentElement.style.display = 'block';
            
            const config = document.getElementById('arrayConfig').value;
            const [rows, cols] = config.split('x').map(Number);
            const Rx = parseFloat(document.getElementById('Rx').value);
            const Ry = parseFloat(document.getElementById('Ry').value);
            const h = parseFloat(document.getElementById('h').value);
            const n = parseFloat(document.getElementById('n').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const numRays = parseInt(document.getElementById('numRays').value);
            const refractiveIndex = parseFloat(document.getElementById('refractiveIndex').value);
            const propagationDistance = parseFloat(document.getElementById('propagationDistance').value);
            const raySpacing = parseFloat(document.getElementById('raySpacing').value);
            const spacingX = parseFloat(document.getElementById('spacingX').value);
            const spacingY = parseFloat(document.getElementById('spacingY').value);
            
            const traces = [];
            const allEndPoints = [];
            
            // Î†åÏ¶à ÌëúÎ©¥ Í∑∏Î¶¨Í∏∞ (ÏÑ†ÌÉùÎêú Î∞∞Ïó¥ Íµ¨ÏÑ±Ïóê ÎßûÍ≤å)
            traces.push({
                x: data.x,
                y: data.y[0],
                z: data.z,
                type: 'surface',
                colorscale: 'Greys',
                opacity: 0.7,
                showscale: false,
                name: 'Î†åÏ¶à ÌëúÎ©¥'
            });
            
            // Ï†ÑÏ≤¥ Î∞∞Ïó¥ ÏòÅÏó≠Ïóê Í∑†Îì±ÌïòÍ≤å Í¥ëÏÑ† Î∂ÑÌè¨
            const colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'yellow', 'cyan', 'magenta'];
            let rayIndex = 0;
            
            const totalWidth = cols * spacingX;
            const totalHeight = rows * spacingY;
            const raysPerSide = Math.ceil(Math.sqrt(numRays));
            
            const rayStepX = totalWidth * raySpacing / (raysPerSide - 1);
            const rayStepY = totalHeight * raySpacing / (raysPerSide - 1);
            
            for (let i = 0; i < raysPerSide; i++) {
                for (let j = 0; j < raysPerSide; j++) {
                    const startX = (i - (raysPerSide-1)/2) * rayStepX;
                    const startY = (j - (raysPerSide-1)/2) * rayStepY;
                    
                    const rayResult = traceRayThroughLensArray(
                        startX, startY, config, spacingX, spacingY, 
                        Rx, Ry, h, n, alpha, refractiveIndex, propagationDistance
                    );
                    
                    const rayX = rayResult.path.map(p => p.x);
                    const rayY = rayResult.path.map(p => p.y);
                    const rayZ = rayResult.path.map(p => p.z);
                    
                    traces.push({
                        x: rayX,
                        y: rayY,
                        z: rayZ,
                        type: 'scatter3d',
                        mode: 'lines+markers',
                        name: `Í¥ëÏÑ† ${rayIndex+1}`,
                        line: { color: colors[rayIndex % colors.length], width: 4 },
                        marker: { size: 2 },
                        showlegend: false
                    });
                    
                    if (rayResult.focused) {
                        allEndPoints.push(rayResult);
                    }
                    
                    rayIndex++;
                    if (rayIndex >= 50) break; // ÏÑ±Îä•ÏùÑ ÏúÑÌïú Ï†úÌïú
                }
                if (rayIndex >= 50) break;
            }
            
            // Ï†ÑÏ≤¥ ÏßëÏÜçÏ†ê Í≥ÑÏÇ∞
            const globalFocalPoint = calculateFocalPoint(allEndPoints);
            let focalInfo = "ÏßëÏÜçÏ†ê Ï†ïÎ≥¥ ÏóÜÏùå";
            
            if (globalFocalPoint) {
                focalInfo = `ÏßëÏÜçÏ†ê: (${globalFocalPoint.x.toFixed(3)}, ${globalFocalPoint.y.toFixed(3)}, ${globalFocalPoint.z.toFixed(3)}) Œºm | ${globalFocalPoint.count}Í∞ú Í¥ëÏÑ† ÏßëÏÜç`;
                
                // ÏßëÏÜçÏ†êÏùÑ ÌÅ∞ ÎßàÏª§Î°ú ÌëúÏãú
                traces.push({
                    x: [globalFocalPoint.x],
                    y: [globalFocalPoint.y],
                    z: [globalFocalPoint.z],
                    type: 'scatter3d',
                    mode: 'markers',
                    name: 'ÏßëÏÜçÏ†ê',
                    marker: { 
                        size: 15, 
                        color: 'red',
                        symbol: 'diamond'
                    },
                    showlegend: true
                });
            }
            
            const layout = {
                title: `3D Í¥ëÏÑ† Ï∂îÏ†Å - ${config} ÎßàÏù¥ÌÅ¨Î°ú Î†åÏ¶à Ïñ¥Î†àÏù¥<br><span style="font-size:12px">${focalInfo}</span>`,
                scene: {
                    xaxis: { title: 'X (Œºm)' },
                    yaxis: { title: 'Y (Œºm)' },
                    zaxis: { title: 'Z (Œºm)' },
                    aspectmode: 'data'
                },
                showlegend: true
            };
            
            Plotly.newPlot('plot', traces, layout);
        }
        
        // ÏÑ§Ï†ïÏùÑ ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨
        async function copyConfigurationToClipboard() {
            const config = {
                arrayConfig: document.getElementById('arrayConfig').value,
                spacingX: parseFloat(document.getElementById('spacingX').value),
                spacingY: parseFloat(document.getElementById('spacingY').value),
                Rx: parseFloat(document.getElementById('Rx').value),
                Ry: parseFloat(document.getElementById('Ry').value),
                h: parseFloat(document.getElementById('h').value),
                n: parseFloat(document.getElementById('n').value),
                alpha: parseFloat(document.getElementById('alpha').value),
                resolution: parseInt(document.getElementById('resolution').value),
                colormap: document.getElementById('colormap').value,
                numRays: parseInt(document.getElementById('numRays').value),
                refractiveIndex: parseFloat(document.getElementById('refractiveIndex').value),
                propagationDistance: parseFloat(document.getElementById('propagationDistance').value),
                raySpacing: parseFloat(document.getElementById('raySpacing').value),
                exportDate: new Date().toISOString(),
                version: '2.0'
            };
            
            const configText = JSON.stringify(config, null, 2);
            
            try {
                await navigator.clipboard.writeText(configText);
                
                // ÌÖçÏä§Ìä∏ ÏòÅÏó≠ÏóêÎèÑ ÌëúÏãú
                document.getElementById('configTextarea').value = configText;
                
                // ÏÑ±Í≥µ Î©îÏãúÏßÄ
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '‚úÖ Î≥µÏÇ¨Îê®!';
                button.style.background = '#27ae60';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 2000);
                
            } catch (err) {
                // ÌÅ¥Î¶ΩÎ≥¥Îìú APIÍ∞Ä ÏßÄÏõêÎêòÏßÄ ÏïäÎäî Í≤ΩÏö∞ ÌÖçÏä§Ìä∏ ÏòÅÏó≠ÏóêÎßå ÌëúÏãú
                document.getElementById('configTextarea').value = configText;
                document.getElementById('configTextarea').select();
                alert('ÏÑ§Ï†ïÏù¥ ÌÖçÏä§Ìä∏ ÏòÅÏó≠Ïóê ÌëúÏãúÎêòÏóàÏäµÎãàÎã§. ÏàòÎèôÏúºÎ°ú Î≥µÏÇ¨Ìï¥Ï£ºÏÑ∏Ïöî.');
            }
        }
        
        // ÏÑ§Ï†ï Ï†ÅÏö©
        function applyConfiguration() {
            const configText = document.getElementById('configTextarea').value.trim();
            
            if (!configText) {
                alert('ÏÑ§Ï†ï ÌÖçÏä§Ìä∏Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }
            
            try {
                const config = JSON.parse(configText);
                
                // ÏÑ§Ï†ï Í∞í Ï†ÅÏö©
                if (config.arrayConfig) document.getElementById('arrayConfig').value = config.arrayConfig;
                if (config.spacingX !== undefined) {
                    document.getElementById('spacingX').value = config.spacingX;
                    updateValueDisplay('spacingX', config.spacingX);
                }
                if (config.spacingY !== undefined) {
                    document.getElementById('spacingY').value = config.spacingY;
                    updateValueDisplay('spacingY', config.spacingY);
                }
                if (config.Rx !== undefined) {
                    document.getElementById('Rx').value = config.Rx;
                    updateValueDisplay('Rx', config.Rx);
                }
                if (config.Ry !== undefined) {
                    document.getElementById('Ry').value = config.Ry;
                    updateValueDisplay('Ry', config.Ry);
                }
                if (config.h !== undefined) {
                    document.getElementById('h').value = config.h;
                    updateValueDisplay('h', config.h);
                }
                if (config.n !== undefined) {
                    document.getElementById('n').value = config.n;
                    updateValueDisplay('n', config.n);
                }
                if (config.alpha !== undefined) {
                    document.getElementById('alpha').value = config.alpha;
                    updateValueDisplay('alpha', config.alpha);
                }
                if (config.resolution !== undefined) {
                    document.getElementById('resolution').value = config.resolution;
                    updateValueDisplay('resolution', config.resolution);
                }
                if (config.colormap) document.getElementById('colormap').value = config.colormap;
                if (config.numRays !== undefined) {
                    document.getElementById('numRays').value = config.numRays;
                    updateValueDisplay('numRays', config.numRays);
                }
                if (config.refractiveIndex !== undefined) {
                    document.getElementById('refractiveIndex').value = config.refractiveIndex;
                    updateValueDisplay('refractiveIndex', config.refractiveIndex);
                }
                if (config.propagationDistance !== undefined) {
                    document.getElementById('propagationDistance').value = config.propagationDistance;
                    updateValueDisplay('propagationDistance', config.propagationDistance);
                }
                if (config.raySpacing !== undefined) {
                    document.getElementById('raySpacing').value = config.raySpacing;
                    updateValueDisplay('raySpacing', config.raySpacing);
                }
                
                // ÌîåÎ°Ø ÏóÖÎç∞Ïù¥Ìä∏
                updatePlot();
                
                // ÏÑ±Í≥µ Î©îÏãúÏßÄ
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '‚úÖ Ï†ÅÏö©Îê®!';
                button.style.background = '#27ae60';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 2000);
                
            } catch (error) {
                alert('ÏÑ§Ï†ï ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§: ' + error.message);
            }
        }
        
        // Í∏∞Î≥∏Í∞í Î≥µÏõê
        function resetToDefaults() {
            document.getElementById('arrayConfig').value = '1x1';
            document.getElementById('spacingX').value = 1.0;
            document.getElementById('spacingY').value = 1.0;
            document.getElementById('Rx').value = 1.3;
            document.getElementById('Ry').value = 1.3;
            document.getElementById('h').value = 0.5;
            document.getElementById('n').value = 2.0;
            document.getElementById('alpha').value = 1.0;
            document.getElementById('resolution').value = 100;
            document.getElementById('colormap').value = 'Viridis';
            document.getElementById('numRays').value = 20;
            document.getElementById('refractiveIndex').value = 1.5;
            document.getElementById('propagationDistance').value = 10;
            document.getElementById('raySpacing').value = 0.3;
            
            // Í∞í ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
            updateValueDisplay('spacingX', 1.0);
            updateValueDisplay('spacingY', 1.0);
            updateValueDisplay('Rx', 1.3);
            updateValueDisplay('Ry', 1.3);
            updateValueDisplay('h', 0.5);
            updateValueDisplay('n', 2.0);
            updateValueDisplay('alpha', 1.0);
            updateValueDisplay('resolution', 100);
            updateValueDisplay('numRays', 20);
            updateValueDisplay('refractiveIndex', 1.5);
            updateValueDisplay('propagationDistance', 10);
            updateValueDisplay('raySpacing', 0.3);
            
            updatePlot();
        }
        
        // Î©îÏù∏ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
        function updatePlot() {
            const config = document.getElementById('arrayConfig').value;
            const Rx = parseFloat(document.getElementById('Rx').value);
            const Ry = parseFloat(document.getElementById('Ry').value);
            const h = parseFloat(document.getElementById('h').value);
            const n = parseFloat(document.getElementById('n').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const resolution = parseInt(document.getElementById('resolution').value);
            const spacingX = parseFloat(document.getElementById('spacingX').value);
            const spacingY = parseFloat(document.getElementById('spacingY').value);
            const colormap = document.getElementById('colormap').value;
            
            const data = generateLensArray(config, Rx, Ry, h, n, alpha, resolution, spacingX, spacingY);
            
            switch (currentView) {
                case 'Contour':
                    plotContour(data, colormap);
                    break;
                case '2D':
                    plot2D(data, colormap);
                    break;
                case '3D':
                    plot3D(data, colormap);
                    break;
                case 'Ray2D':
                    plotRay2D(data, colormap);
                    break;
                case 'Ray3D':
                    plotRay3D(data, colormap);
                    break;
            }
        }
        
        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
        document.addEventListener('DOMContentLoaded', function() {
            // Ïä¨ÎùºÏù¥Îçî Ïù¥Î≤§Ìä∏
            ['Rx', 'Ry', 'h', 'n', 'alpha', 'resolution', 'spacingX', 'spacingY', 'numRays', 'refractiveIndex', 'propagationDistance', 'raySpacing'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', function() {
                        updateValueDisplay(id, this.value);
                        updatePlot();
                    });
                    updateValueDisplay(id, element.value);
                }
            });
            
            // ÏÑ†ÌÉù Î∞ïÏä§ Ïù¥Î≤§Ìä∏
            ['arrayConfig', 'colormap'].forEach(id => {
                document.getElementById(id).addEventListener('change', updatePlot);
            });
            
            // Î∑∞ Î≤ÑÌäº Ïù¥Î≤§Ìä∏
            document.getElementById('viewContour').addEventListener('click', function() {
                currentView = 'Contour';
                updateViewButtons();
                updatePlot();
            });
            
            document.getElementById('view2D').addEventListener('click', function() {
                currentView = '2D';
                updateViewButtons();
                updatePlot();
            });
            
            document.getElementById('view3D').addEventListener('click', function() {
                currentView = '3D';
                updateViewButtons();
                updatePlot();
            });
            
            document.getElementById('viewRay2D').addEventListener('click', function() {
                currentView = 'Ray2D';
                updateViewButtons();
                updatePlot();
            });
            
            document.getElementById('viewRay3D').addEventListener('click', function() {
                currentView = 'Ray3D';
                updateViewButtons();
                updatePlot();
            });
            
            // Ï¥àÍ∏∞ ÌîåÎ°Ø ÏÉùÏÑ±
            updatePlot();
        });
        
        function updateViewButtons() {
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            if (currentView === 'Contour') {
                document.getElementById('viewContour').classList.add('active');
            } else if (currentView === '2D') {
                document.getElementById('view2D').classList.add('active');
            } else if (currentView === '3D') {
                document.getElementById('view3D').classList.add('active');
            } else if (currentView === 'Ray2D') {
                document.getElementById('viewRay2D').classList.add('active');
            } else if (currentView === 'Ray3D') {
                document.getElementById('viewRay3D').classList.add('active');
            }
        }
    </script>
</body>
</html>