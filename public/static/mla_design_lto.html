<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML ì‹œê°í™” ë„êµ¬</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ”¬</text></svg>">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.16.1/plotly.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            width: 98%;
            max-width: none;
            margin: 0;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 0;
            padding: 20px;
            box-shadow: none;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            display: flex;
            gap: 20px;
            flex: 1;
        }

        .left-panel {
            flex: 0 0 350px;
            min-width: 350px;
        }

        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .controls {
            margin-bottom: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            padding: 10px;
        }

        .view-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .plot-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            flex: 1;
        }

        .plot-container #plot {
            width: 100%;
            height: calc(100vh - 300px);
            min-height: 600px;
        }

        .plot-container #multiViewContainer {
            height: calc(100vh - 300px);
            min-height: 600px;
        }

        .plot-container #multiViewContainer > div {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 100%;
        }

        .plot-container #multiViewContainer > div > div {
            height: calc((100vh - 340px) / 2);
            min-height: 280px;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #3498db, #9b59b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls {
            margin-bottom: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            padding: 10px;
        }

        .control-section {
            margin-bottom: 10px;
        }

        .control-header {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .control-header:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .control-header .arrow {
            font-size: 14px;
            transition: transform 0.3s ease;
        }

        .control-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        .control-content {
            background: white;
            border-radius: 0 0 10px 10px;
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            max-height: 700px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .control-content.collapsed {
            max-height: 0;
            padding: 0 20px;
        }

        .control-item {
            margin-bottom: 15px;
        }

        .control-item label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 14px;
        }

        .control-item input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }

        .control-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .control-item select, .control-item button {
            width: 100%;
            padding: 8px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            background: white;
            font-size: 14px;
            cursor: pointer;
        }

        .control-item select:focus, .control-item button:focus {
            border-color: #3498db;
            outline: none;
        }

        .value-display {
            font-size: 12px;
            color: #7f8c8d;
            text-align: right;
        }

        .view-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .view-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .view-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .view-btn.active {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .plot-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            flex: 1;
        }

        .plot-container #plot {
            width: 100%;
            height: calc(100vh - 300px);
            min-height: 600px;
        }

        .plot-container #multiViewContainer {
            height: calc(100vh - 300px);
            min-height: 600px;
        }

        .plot-container #multiViewContainer > div {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 100%;
        }

        .plot-container #multiViewContainer > div > div {
            height: calc((100vh - 340px) / 2);
            min-height: 280px;
        }

        .info-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
        }

        .info-panel h3 {
            margin-top: 0;
        }

        .formula-compact {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-family: 'Times New Roman', serif;
            line-height: 1.6;
        }

        .math-formula {
            font-family: 'Times New Roman', serif;
            font-size: 14px;
            font-style: italic;
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            border-radius: 3px;
            display: inline;
            margin: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”¬ ë§ˆì´í¬ë¡œ ë Œì¦ˆ ì‹œê°í™” ë„êµ¬</h1>

        <div class="main-content">
            <div class="left-panel">
                <div class="controls">
                    <div class="control-section">
                        <div class="control-header" onclick="toggleSection('config')">
                            <span>âš™ï¸ ì„¤ì • ë° ì‹œê°í™” ê´€ë¦¬</span>
                            <span class="arrow">â–¼</span>
                        </div>
                        <div class="control-content collapsed" id="config-content">
                            <div class="control-item">
                                <button onclick="resetToDefaults()">ğŸ”„ ê¸°ë³¸ê°’ ë³µì›</button>
                                <button onclick="copyConfigurationToClipboard()">ğŸ“‹ ì„¤ì • ë³µì‚¬ (Copy)</button>
                            </div>
                            <div class="control-item">
                                <label for="configTextarea">ì„¤ì • ë¶™ì—¬ë„£ê¸°:</label>
                                <textarea id="configTextarea" rows="15" style="width: 100%; font-family: monospace; font-size: 12px; border: 2px solid #bdc3c7; border-radius: 5px; padding: 8px;" placeholder="ì—¬ê¸°ì— ì„¤ì • JSONì„ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”..."></textarea>
                                <button onclick="applyConfiguration()">âœ… ì„¤ì • ì ìš©</button>
                            </div>
                            <div class="control-item">
                                <label for="resolution">í•´ìƒë„: <span class="value-display" id="resolutionValue">100</span></label>
                                <input type="range" id="resolution" min="10" max="200" step="10" value="100">
                            </div>

                            <div class="control-item">
                                <label for="colormap">ìƒ‰ìƒ ë§µ:</label>
                                <select id="colormap">
                                    <option value="Viridis">Viridis</option>
                                    <option value="Plasma">Plasma</option>
                                    <option value="Inferno">Inferno</option>
                                    <option value="Magma">Magma</option>
                                    <option value="Jet">Jet</option>
                                    <option value="Hot">Hot</option>
                                    <option value="Cool">Cool</option>
                                    <option value="Rainbow">Rainbow</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div class="control-section">
                        <div class="control-header" onclick="toggleSection('array')">
                            <span>ğŸ”¢ ë°°ì—´ êµ¬ì„±</span>
                            <span class="arrow">â–¼</span>
                        </div>
                        <div class="control-content" id="array-content">
                            <div class="control-item">
                                <label for="arrayConfig">ë°°ì—´ êµ¬ì„±:</label>
                                <select id="arrayConfig">
                                    <option value="1x1" selected>1Ã—1 (ë‹¨ì¼ ë Œì¦ˆ)</option>
                                    <option value="2x1">2Ã—1 (ì„¸ë¡œ 2ê°œ)</option>
                                    <option value="1x2">1Ã—2 (ê°€ë¡œ 2ê°œ)</option>
                                    <option value="2x2">2Ã—2 (2Ã—2 ë°°ì—´)</option>
                                    <option value="3x3">3Ã—3 (3Ã—3 ë°°ì—´)</option>
                                    <option value="4x4">4Ã—4 (4Ã—4 ë°°ì—´)</option>
                                </select>
                            </div>

                            <div class="control-item">
                                <label for="spacingX">ë Œì¦ˆ ê°„ê²© X (Î¼m): <span class="value-display" id="spacingXValue">1.0 Î¼m</span></label>
                                <input type="range" id="spacingX" min="0.1" max="2.0" step="0.01" value="1.0">
                            </div>

                            <div class="control-item">
                                <label for="spacingY">ë Œì¦ˆ ê°„ê²© Y (Î¼m): <span class="value-display" id="spacingYValue">1.0 Î¼m</span></label>
                                <input type="range" id="spacingY" min="0.1" max="2.0" step="0.01" value="1.0">
                            </div>
                        </div>
                    </div>

                    <div class="control-section">
                        <div class="control-header" onclick="toggleSection('lens')">
                            <span>ğŸ” ë Œì¦ˆ í˜•íƒœ íŒŒë¼ë¯¸í„°</span>
                            <span class="arrow">â–¼</span>
                        </div>
                        <div class="control-content" id="lens-content">
                            <div class="control-item">
                                <label for="ltoThickness">LTO ë‘ê»˜ (Î¼m): <span class="value-display" id="ltoThicknessValue">0.1 Î¼m</span></label>
                                <input type="range" id="ltoThickness" min="0.01" max="0.5" step="0.01" value="0.1">
                            </div>

                            <div class="control-item">
                                <label for="ltoRefractiveIndex">LTO êµ´ì ˆë¥ : <span class="value-display" id="ltoRefractiveIndexValue">1.46</span></label>
                                <input type="range" id="ltoRefractiveIndex" min="1.3" max="1.6" step="0.01" value="1.46">
                            </div>

                            <div class="control-item">
                                <label for="h">ë Œì¦ˆ ë†’ì´ (h, Î¼m): <span class="value-display" id="hValue">0.5 Î¼m</span></label>
                                <input type="range" id="h" min="0.1" max="1.0" step="0.01" value="0.5">
                            </div>

                            <div class="control-item">
                                <label for="refractiveIndex">ë Œì¦ˆ êµ´ì ˆë¥ : <span class="value-display" id="refractiveIndexValue">1.5</span></label>
                                <input type="range" id="refractiveIndex" min="1.3" max="1.8" step="0.01" value="1.5">
                            </div>

                            <div class="control-item">
                                <label for="Rx">ë°˜ì§€ë¦„ X (Rx, Î¼m): <span class="value-display" id="RxValue">0.6 Î¼m</span></label>
                                <input type="range" id="Rx" min="0.1" max="3.0" step="0.01" value="0.6">
                            </div>

                            <div class="control-item">
                                <label for="Ry">ë°˜ì§€ë¦„ Y (Ry, Î¼m): <span class="value-display" id="RyValue">0.6 Î¼m</span></label>
                                <input type="range" id="Ry" min="0.1" max="3.0" step="0.01" value="0.6">
                            </div>

                            <div class="control-item">
                                <label for="n">ìŠˆí¼ì—˜ë¦½ìŠ¤ ì§€ìˆ˜ (n): <span class="value-display" id="nValue">2.0</span></label>
                                <input type="range" id="n" min="1.0" max="5.0" step="0.05" value="2.0">
                            </div>

                            <div class="control-item">
                                <label for="alpha">ê³¡ë¥  íŒŒë¼ë¯¸í„° (Î±): <span class="value-display" id="alphaValue">1.0</span></label>
                                <input type="range" id="alpha" min="0.1" max="2.0" step="0.01" value="1.0">
                            </div>
                        </div>
                    </div>

                    <div class="control-section">
                        <div class="control-header" onclick="toggleSection('ray')">
                            <span>ğŸŒˆ ê´‘ì„  ì¶”ì  ì„¤ì •</span>
                            <span class="arrow">â–¼</span>
                        </div>
                        <div class="control-content" id="ray-content">
                            <div class="control-item">
                                <label for="incidenceTheta">ì…ì‚¬ê° Î¸ (degree): <span class="value-display" id="incidenceThetaValue">0Â°</span></label>
                                <input type="range" id="incidenceTheta" min="-45" max="45" step="1" value="0">
                            </div>

                            <div class="control-item">
                                <label for="incidencePhi">ë°©ìœ„ê° Ï† (degree): <span class="value-display" id="incidencePhiValue">0Â°</span></label>
                                <input type="range" id="incidencePhi" min="-180" max="180" step="5" value="0">
                            </div>

                            <div class="control-item">
                                <label for="numRays">ê´‘ì„  ìˆ˜ (per ë Œì¦ˆ): <span class="value-display" id="numRaysValue">20</span></label>
                                <input type="range" id="numRays" min="3" max="64" step="1" value="36">
                            </div>

                            <div class="control-item">
                                <label for="propagationDistance">ì „íŒŒ ê±°ë¦¬ (Î¼m): <span class="value-display" id="propagationDistanceValue">2 Î¼m</span></label>
                                <input type="range" id="propagationDistance" min="1" max="80" step="1" value="2">
                            </div>

                            <div class="control-item">
                                <label for="raySpacing">ê´‘ì„  ê°„ê²©: <span class="value-display" id="raySpacingValue">0.9</span></label>
                                <input type="range" id="raySpacing" min="0.5" max="2.0" step="0.1" value="1.5">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="right-panel">
                <div class="view-controls">
                    <button class="view-btn active" id="viewContour">ì»¨íˆ¬ì–´ ë·°</button>
                    <button class="view-btn" id="view2D">2D ë“±ê³ ì„  ë·°</button>
                    <button class="view-btn" id="view3D">3D ì„œí”¼ìŠ¤ ë·°</button>
                    <button class="view-btn" id="viewRay2D">2D ê´‘ì„  ì¶”ì </button>
                    <button class="view-btn" id="viewRay3D">3D ê´‘ì„  ì¶”ì </button>
                </div>

                <div class="plot-container">
                    <div id="plot" style="width: 100%; height: 800px;"></div>
                </div>

                <div class="plot-container" id="multiViewContainer" style="display: none;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; height: 920px;">
                        <div id="subView1" style="height: 450px;"></div>
                        <div id="subView2" style="height: 450px;"></div>
                        <div id="subView3" style="height: 450px;"></div>
                        <div id="subView4" style="height: 450px;"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <h3>ğŸ“ ìˆ˜í•™ì  ëª¨ë¸</h3>
            <div class="formula-compact">
                <strong>ìŠˆí¼ì—˜ë¦½ìŠ¤ ë°©ì •ì‹:</strong> <span class="math-formula">|x/Rx|^n + |y/Ry|^n = 1</span><br>
                <strong>ë Œì¦ˆ ë†’ì´ ë°©ì •ì‹:</strong> <span class="math-formula">z(r) = h Ã— (1 - rÂ²)^(1/(2Î±))</span><br>
                <strong>ê±°ë¦¬ ê³µì‹:</strong> <span class="math-formula">r = (|x/Rx|^n + |y/Ry|^n)^(1/n)</span><br>
                <strong>ìŠ¤ë„¬ì˜ ë²•ì¹™:</strong> <span class="math-formula">nâ‚sin(Î¸â‚) = nâ‚‚sin(Î¸â‚‚)</span><br>
                <strong>LTO ì¸µ:</strong> <span class="math-formula">ì €ì˜¨ ì‚°í™”ë§‰ ì¸µ, ML ìœ„ì— ì ì¸µ</span><br>
                <strong>ê´‘ì„  êµ´ì ˆ:</strong> <span class="math-formula">ê³µê¸°â†’LTOâ†’ë Œì¦ˆ ìˆœì„œë¡œ êµ´ì ˆ</span><br>
                <strong>ì‚¬ê´‘ ì…ì‚¬:</strong> <span class="math-formula">Î¸(ì…ì‚¬ê°), Ï†(ë°©ìœ„ê°) ì§€ì›</span><br>
                <strong>íŒŒë¼ë¯¸í„°:</strong> Rx,Ry(ë°˜ì§€ë¦„), h(ë†’ì´), n(ìŠˆí¼ì—˜ë¦½ìŠ¤ ì§€ìˆ˜), Î±(ê³¡ë¥ ), ëª¨ë“  ì¹˜ìˆ˜ëŠ” Î¼m ë‹¨ìœ„
            </div>
        </div>
    </div>

    <script>
        let currentView = 'Contour';

        // ì„¹ì…˜ í† ê¸€ í•¨ìˆ˜
        function toggleSection(sectionId) {
            const content = document.getElementById(sectionId + '-content');
            const header = content.previousElementSibling;

            content.classList.toggle('collapsed');
            header.classList.toggle('collapsed');
        }

        // íŒŒë¼ë¯¸í„° ê°’ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateValueDisplay(id, value) {
            let displayValue = value;
            if (id === 'Rx' || id === 'Ry' || id === 'h' || id === 'spacingX' || id === 'spacingY' || id === 'propagationDistance' || id === 'ltoThickness') {
                displayValue = value + ' Î¼m';
            } else if (id === 'incidenceTheta' || id === 'incidencePhi') {
                displayValue = value + 'Â°';
            }
            const element = document.getElementById(id + 'Value');
            if (element) {
                element.textContent = displayValue;
            }
        }

        // íƒ€ì›í˜• ìŠˆí¼ì—˜ë¦½ìŠ¤ ê±°ë¦¬ ê³„ì‚°
        function superellipseDistance(x, y, Rx, Ry, n) {
            return Math.pow(Math.pow(Math.abs(x / Rx), n) + Math.pow(Math.abs(y / Ry), n), 1/n);
        }

        // ë Œì¦ˆ ë†’ì´ ê³„ì‚° (ML í‘œë©´ë§Œ)
        function lensHeight(r, h, alpha) {
            if (r > 1) return 0;
            return h * Math.pow(1 - r * r, 1 / (2 * alpha));
        }

        // ë¶„ë¦¬ëœ í‘œë©´ ìƒì„±: ML í‘œë©´ê³¼ LTO í‘œë©´
        function generateSeparatedSurfaces(config, Rx, Ry, h, n, alpha, resolution, spacingX, spacingY, ltoThickness) {
            const [rows, cols] = config.split('x').map(Number);

            // ì „ì²´ ì˜ì—­ í¬ê¸° ê³„ì‚°
            const totalWidth = cols * spacingX;
            const totalHeight = rows * spacingY;
            const maxSizeX = totalWidth / 2;
            const maxSizeY = totalHeight / 2;

            const stepX = totalWidth / resolution;
            const stepY = totalHeight / resolution;
            const x = [];
            const y = [];
            const mlSurface = [];  // ML í‘œë©´
            const ltoSurface = []; // LTO í‘œë©´

            for (let i = 0; i <= resolution; i++) {
                const xi = -maxSizeX + i * stepX;
                const row_y = [];
                const row_ml = [];
                const row_lto = [];

                for (let j = 0; j <= resolution; j++) {
                    const yi = -maxSizeY + j * stepY;
                    let maxML = 0;    // ML ìµœëŒ€ ë†’ì´
                    let maxLTO = ltoThickness; // LTO ê¸°ë³¸ ë‘ê»˜

                    // ê° ë Œì¦ˆ ìœ„ì¹˜ì—ì„œ ë†’ì´ ê³„ì‚°
                    for (let row = 0; row < rows; row++) {
                        for (let col = 0; col < cols; col++) {
                            const centerX = (col - (cols - 1) / 2) * spacingX;
                            const centerY = (row - (rows - 1) / 2) * spacingY;

                            const relX = xi - centerX;
                            const relY = yi - centerY;

                            const r = superellipseDistance(relX, relY, Rx, Ry, n);

                            if (r <= 1) {
                                const mlHeight = h * Math.pow(1 - r * r, 1 / (2 * alpha));
                                const ltoHeight = mlHeight + ltoThickness;

                                maxML = Math.max(maxML, mlHeight);
                                maxLTO = Math.max(maxLTO, ltoHeight);
                            }
                        }
                    }

                    row_y.push(yi);
                    row_ml.push(maxML);
                    row_lto.push(maxLTO);
                }

                x.push(xi);
                y.push(row_y);
                mlSurface.push(row_ml);
                ltoSurface.push(row_lto);
            }

            return {
                x,
                y,
                mlSurface,   // ML í‘œë©´ Z ì¢Œí‘œ
                ltoSurface   // LTO í‘œë©´ Z ì¢Œí‘œ
            };
        }

        // ë‹¨ì¼ ë Œì¦ˆì˜ ë¶„ë¦¬ëœ í‘œë©´
        function generateSingleLensSeparatedSurfaces(Rx, Ry, h, n, alpha, resolution, sizeX, sizeY, ltoThickness) {
            const stepX = (2 * sizeX) / resolution;
            const stepY = (2 * sizeY) / resolution;
            const x = [];
            const y = [];
            const mlSurface = [];
            const ltoSurface = [];

            for (let i = 0; i <= resolution; i++) {
                const xi = -sizeX + i * stepX;
                const row_y = [];
                const row_ml = [];
                const row_lto = [];

                for (let j = 0; j <= resolution; j++) {
                    const yi = -sizeY + j * stepY;
                    const r = superellipseDistance(xi, yi, Rx, Ry, n);

                    let mlZ = 0;
                    let ltoZ = ltoThickness;

                    if (r <= 1) {
                        mlZ = h * Math.pow(1 - r * r, 1 / (2 * alpha));
                        ltoZ = mlZ + ltoThickness;
                    }

                    row_y.push(yi);
                    row_ml.push(mlZ);
                    row_lto.push(ltoZ);
                }

                x.push(xi);
                y.push(row_y);
                mlSurface.push(row_ml);
                ltoSurface.push(row_lto);
            }

            return { x, y, mlSurface, ltoSurface };
        }

        // ì…ì‚¬ê°ì„ ê³ ë ¤í•œ ì´ˆê¸° ê´‘ì„  ë°©í–¥ ê³„ì‚°
        function calculateIncidentDirection(thetaDeg, phiDeg) {
            const theta = thetaDeg * Math.PI / 180; // degree to radian
            const phi = phiDeg * Math.PI / 180;

            // êµ¬ë©´ ì¢Œí‘œê³„ì—ì„œ ì§êµ ì¢Œí‘œê³„ë¡œ ë³€í™˜
            // theta: ìˆ˜ì§ì¶•(Z)ì—ì„œì˜ ê°ë„, phi: XY í‰ë©´ì—ì„œì˜ ë°©ìœ„ê°
            const dx = Math.sin(theta) * Math.cos(phi);
            const dy = Math.sin(theta) * Math.sin(phi);
            const dz = -Math.cos(theta); // í•˜í–¥ì„ ìŒìˆ˜ë¡œ

            return { dx, dy, dz };
        }

        // ì‚¬ê´‘ ì…ì‚¬ë¥¼ ê³ ë ¤í•œ ì‹œì‘ì  ê³„ì‚°
        function calculateStartPosition(targetX, targetY, incidentDirection, startHeight) {
            // íƒ€ê²Ÿ ìœ„ì¹˜ì—ì„œ ì—­ë°©í–¥ìœ¼ë¡œ ê³„ì‚°í•˜ì—¬ ì‹œì‘ì  êµ¬í•˜ê¸°
            // ê´‘ì„ ì´ (targetX, targetY, ltoZ)ì— ë„ë‹¬í•˜ë„ë¡ í•˜ëŠ” ì‹œì‘ì  ê³„ì‚°

            const distance = startHeight / Math.abs(incidentDirection.dz); // Z ë°©í–¥ ê±°ë¦¬

            const startX = targetX - incidentDirection.dx * distance;
            const startY = targetY - incidentDirection.dy * distance;

            return { startX, startY };
        }

        // ë Œì¦ˆ í‘œë©´ì˜ ë²•ì„  ë²¡í„° ê³„ì‚°
        function calculateSurfaceNormal(x, y, Rx, Ry, h, n, alpha) {
            const r = superellipseDistance(x, y, Rx, Ry, n);
            if (r >= 1) return { nx: 0, ny: 0, nz: 1 }; // í‰ë©´ ì˜ì—­

            // ìˆ˜ì¹˜ì  ë¯¸ë¶„ìœ¼ë¡œ ë²•ì„  ê³„ì‚°
            const eps = 0.001;
            const z0 = h * Math.pow(1 - r * r, 1 / (2 * alpha));

            const rx = superellipseDistance(x + eps, y, Rx, Ry, n);
            const ry = superellipseDistance(x, y + eps, Rx, Ry, n);

            let zx = 0, zy = 0;
            if (rx < 1) zx = h * Math.pow(1 - rx * rx, 1 / (2 * alpha));
            if (ry < 1) zy = h * Math.pow(1 - ry * ry, 1 / (2 * alpha));

            const dzdx = (zx - z0) / eps;
            const dzdy = (zy - z0) / eps;

            // ë²•ì„  ë²¡í„° ì •ê·œí™”
            const length = Math.sqrt(dzdx * dzdx + dzdy * dzdy + 1);
            return { nx: -dzdx / length, ny: -dzdy / length, nz: 1 / length };
        }

        // ìŠ¤ë„¬ì˜ ë²•ì¹™ì„ ì´ìš©í•œ êµ´ì ˆ ê³„ì‚°
        function refractRay(incident, normal, n1, n2) {
            const { dx, dy, dz } = incident;
            const { nx, ny, nz } = normal;

            // ì…ì‚¬ê° ê³„ì‚°
            const cosI = -(dx * nx + dy * ny + dz * nz);
            const eta = n1 / n2;
            const k = 1 - eta * eta * (1 - cosI * cosI);

            if (k < 0) {
                // ì „ë°˜ì‚¬ - ë°˜ì‚¬ë§Œ ë°œìƒ
                return {
                    dx: dx + 2 * cosI * nx,
                    dy: dy + 2 * cosI * ny,
                    dz: dz + 2 * cosI * nz
                };
            }

            const sqrtK = Math.sqrt(k);
            return {
                dx: eta * dx + (eta * cosI - sqrtK) * nx,
                dy: eta * dy + (eta * cosI - sqrtK) * ny,
                dz: eta * dz + (eta * cosI - sqrtK) * nz
            };
        }

        // íŠ¹ì • ë Œì¦ˆì™€ ê´‘ì„ ì˜ êµì  ê²€ì¶œ (MLê³¼ LTO ë¶„ë¦¬)
        function findRayLensIntersection(rayX, rayY, lensCenterX, lensCenterY, Rx, Ry, h, n, alpha, ltoThickness) {
            // ë Œì¦ˆ ì¤‘ì‹¬ ê¸°ì¤€ ìƒëŒ€ ì¢Œí‘œ
            const relX = rayX - lensCenterX;
            const relY = rayY - lensCenterY;

            // ì´ ë Œì¦ˆ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
            const r = superellipseDistance(relX, relY, Rx, Ry, n);
            if (r > 1) {
                return null; // ì´ ë Œì¦ˆ ë²”ìœ„ ë°–
            }

            // ML í‘œë©´ ë†’ì´ì™€ LTO í‘œë©´ ë†’ì´ ê³„ì‚°
            const mlHeight = h * Math.pow(1 - r * r, 1 / (2 * alpha));
            const ltoHeight = mlHeight + ltoThickness;

            return {
                x: rayX,
                y: rayY,
                mlZ: mlHeight,
                ltoZ: ltoHeight,
                lensCenter: { x: lensCenterX, y: lensCenterY },
                relativePos: { x: relX, y: relY },
                r: r
            };
        }

        // ë°°ì—´ì˜ ëª¨ë“  ë Œì¦ˆì™€ ê´‘ì„ ì˜ êµì  ì°¾ê¸°
        function findAllLensIntersections(rayX, rayY, config, spacingX, spacingY, Rx, Ry, h, n, alpha, ltoThickness) {
            const [rows, cols] = config.split('x').map(Number);
            const intersections = [];

            for (let lensRow = 0; lensRow < rows; lensRow++) {
                for (let lensCol = 0; lensCol < cols; lensCol++) {
                    const lensCenterX = (lensCol - (cols - 1) / 2) * spacingX;
                    const lensCenterY = (lensRow - (rows - 1) / 2) * spacingY;

                    const intersection = findRayLensIntersection(
                        rayX, rayY, lensCenterX, lensCenterY, Rx, Ry, h, n, alpha, ltoThickness
                    );

                    if (intersection) {
                        intersection.lensIndex = { row: lensRow, col: lensCol };
                        intersections.push(intersection);
                    }
                }
            }

            // ê°€ì¥ ë†’ì€ êµì  ì„ íƒ (ìœ„ì— ìˆëŠ” ë Œì¦ˆ)
            if (intersections.length === 0) return null;

            return intersections.reduce((highest, current) =>
                current.ltoZ > highest.ltoZ ? current : highest
            );
        }

        // ì˜¬ë°”ë¥¸ ê´‘ì„  ì¶”ì : 2íšŒ êµ´ì ˆ (LTO í‘œë©´ 1íšŒ, ML í‘œë©´ 1íšŒ) + ì‚¬ê´‘ ì…ì‚¬ ì§€ì›
        function traceRayThroughLensArray(startX, startY, config, spacingX, spacingY, Rx, Ry, h, n, alpha, lensRefractiveIndex, propagationDistance, ltoThickness, ltoRefractiveIndex, incidentDirection) {
            const startZ = h + ltoThickness + 0.1; // ì‹œì‘ ë†’ì´
            const path = [{ x: startX, y: startY, z: startZ }]; // ì‹œì‘ì  (ê³µê¸° ì¤‘)

            // ì‚¬ê´‘ ì…ì‚¬ë¥¼ ê³ ë ¤í•˜ì—¬ LTO í‘œë©´ê³¼ì˜ êµì  ì°¾ê¸°
            // ê´‘ì„ ì´ LTO í‘œë©´ì— ë„ë‹¬í•˜ëŠ” ì‹¤ì œ ìœ„ì¹˜ ê³„ì‚°
            let intersectionX = startX;
            let intersectionY = startY;
            let intersectionFound = false;

            // ìˆ˜ì¹˜ì ìœ¼ë¡œ LTO í‘œë©´ê³¼ì˜ êµì  ì°¾ê¸°
            for (let t = 0; t < 2.0; t += 0.001) {
                const testX = startX + incidentDirection.dx * t;
                const testY = startY + incidentDirection.dy * t;
                const testZ = startZ + incidentDirection.dz * t;

                // í˜„ì¬ ìœ„ì¹˜ì—ì„œ LTO í‘œë©´ ë†’ì´ í™•ì¸
                const testIntersection = findAllLensIntersections(testX, testY, config, spacingX, spacingY, Rx, Ry, h, n, alpha, ltoThickness);

                if (testIntersection && testZ <= testIntersection.ltoZ) {
                    intersectionX = testX;
                    intersectionY = testY;
                    intersectionFound = true;
                    break;
                }
            }

            if (!intersectionFound) {
                // LTO í‘œë©´ê³¼ ë§Œë‚˜ì§€ ì•Šìœ¼ë©´ ì‚¬ê´‘ìœ¼ë¡œ ì§ì§„
                const endX = startX + incidentDirection.dx * propagationDistance;
                const endY = startY + incidentDirection.dy * propagationDistance;
                const endZ = startZ + incidentDirection.dz * propagationDistance;
                path.push({ x: endX, y: endY, z: endZ });
                return { path, focused: false, endPoint: { x: endX, y: endY, z: endZ }, lensIndex: null };
            }

            // ì‹¤ì œ êµì ì—ì„œ LTO í‘œë©´ ì •ë³´ ì¬ê³„ì‚°
            const intersection = findAllLensIntersections(intersectionX, intersectionY, config, spacingX, spacingY, Rx, Ry, h, n, alpha, ltoThickness);

            let currentDirection = { ...incidentDirection }; // ì‚¬ê´‘ ì…ì‚¬ ë°©í–¥
            let currentX = intersectionX;
            let currentY = intersectionY;

            // ê³µê¸° ì¤‘ì—ì„œ LTO í‘œë©´ê¹Œì§€ì˜ ì‚¬ê´‘ ê²½ë¡œ ì¶”ê°€
            path.push({ x: currentX, y: currentY, z: intersection.ltoZ });

            // 1ë‹¨ê³„: ê³µê¸° â†’ LTO í‘œë©´ì—ì„œ êµ´ì ˆ (LTO í‘œë©´ì€ ML í‘œë©´ê³¼ í‰í–‰í•œ ê³¡ë©´)
            // LTO í‘œë©´ì˜ ë²•ì„ ì€ ML í‘œë©´ì˜ ë²•ì„ ê³¼ ë™ì¼
            const ltoNormal = calculateSurfaceNormal(
                intersection.relativePos.x,
                intersection.relativePos.y,
                Rx, Ry, h, n, alpha
            );

            const refracted1 = refractRay(currentDirection, ltoNormal, 1.0, ltoRefractiveIndex);
            currentDirection = refracted1;

            // LTO ë‚´ë¶€ë¥¼ í†µê³¼í•˜ì—¬ ML í‘œë©´ê³¼ì˜ ì‹¤ì œ êµì  ì°¾ê¸°
            // êµ´ì ˆëœ ê´‘ì„ ì´ ML í‘œë©´ì— ì ‘ì´‰í•˜ëŠ” ì ì„ ìˆ˜ì¹˜ì ìœ¼ë¡œ ê³„ì‚°
            let step = 0.001; // ì‘ì€ ìŠ¤í…ìœ¼ë¡œ ì´ë™
            let tempX = currentX;
            let tempY = currentY;
            let tempZ = intersection.ltoZ;

            // ML í‘œë©´ì— ë„ë‹¬í•  ë•Œê¹Œì§€ ë°˜ë³µ ê³„ì‚°
            while (step < 1.0) {
                tempX += currentDirection.dx * step;
                tempY += currentDirection.dy * step;
                tempZ += currentDirection.dz * step;

                // í˜„ì¬ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ë Œì¦ˆì˜ ML í‘œë©´ ë†’ì´ ê³„ì‚°
                const currentMLIntersection = findAllLensIntersections(tempX, tempY, config, spacingX, spacingY, Rx, Ry, h, n, alpha, ltoThickness);
                const currentMLZ = currentMLIntersection ? currentMLIntersection.mlZ : 0;

                // ML í‘œë©´ì— ë„ë‹¬í–ˆëŠ”ì§€ í™•ì¸
                if (tempZ <= currentMLZ) {
                    break;
                }

                step += 0.001;
            }

            // ML í‘œë©´ ì ‘ì´‰ì ìœ¼ë¡œ ì¢Œí‘œ ì—…ë°ì´íŠ¸
            currentX = tempX;
            currentY = tempY;

            // 2ë‹¨ê³„: LTO â†’ ML í‘œë©´ì—ì„œ êµ´ì ˆ (ê³¡ë©´ ê²½ê³„ë©´)
            path.push({ x: currentX, y: currentY, z: intersection.mlZ });

            // ML í‘œë©´ì—ì„œì˜ ë²•ì„  ë²¡í„° ê³„ì‚° (ìƒˆë¡œìš´ ì ‘ì´‰ì  ê¸°ì¤€)
            const finalIntersection = findAllLensIntersections(currentX, currentY, config, spacingX, spacingY, Rx, Ry, h, n, alpha, ltoThickness);
            const mlNormal = calculateSurfaceNormal(
                finalIntersection ? finalIntersection.relativePos.x : 0,
                finalIntersection ? finalIntersection.relativePos.y : 0,
                Rx, Ry, h, n, alpha
            );

            // LTOì—ì„œ ë Œì¦ˆë¡œì˜ êµ´ì ˆ (ì „ë°˜ì‚¬ ë°©ì§€)
            const refracted2 = refractRay(currentDirection, mlNormal, ltoRefractiveIndex, lensRefractiveIndex);

            // ì „ë°˜ì‚¬ê°€ ë°œìƒí•˜ëŠ” ê²½ìš° ê°•ì œë¡œ íˆ¬ê³¼ì‹œí‚´
            if (refracted2.dz >= 0) {
                // ì „ë°˜ì‚¬ ë°©ì§€: ì‘ì€ ê°ë„ë¡œ íˆ¬ê³¼
                currentDirection = {
                    dx: currentDirection.dx * 0.8,
                    dy: currentDirection.dy * 0.8,
                    dz: -Math.abs(currentDirection.dz) * 0.9
                };
            } else {
                currentDirection = refracted2;
            }

            // 3ë‹¨ê³„: ML ë‚´ë¶€ì—ì„œ ì§ì„  ì „íŒŒ (ML ì•„ë˜ìª½ì€ ëª¨ë‘ ë™ì¼í•œ ë§¤ì§ˆì´ë¯€ë¡œ êµ´ì ˆ ì—†ìŒ)
            const endX = currentX + currentDirection.dx * propagationDistance;
            const endY = currentY + currentDirection.dy * propagationDistance;
            const endZ = intersection.mlZ + currentDirection.dz * propagationDistance;

            path.push({ x: endX, y: endY, z: endZ });

            return {
                path,
                focused: true,
                endPoint: { x: endX, y: endY, z: endZ },
                lensIndex: intersection.lensIndex,
                intersection: intersection
            };
        }

        // ì§‘ì†ì  ê³„ì‚°
        function calculateFocalPoint(endPoints) {
            if (endPoints.length === 0) return null;

            let sumX = 0, sumY = 0, sumZ = 0;
            let count = 0;

            endPoints.forEach(point => {
                if (point.focused) {
                    sumX += point.endPoint.x;
                    sumY += point.endPoint.y;
                    sumZ += point.endPoint.z;
                    count++;
                }
            });

            if (count === 0) return null;

            return {
                x: sumX / count,
                y: sumY / count,
                z: sumZ / count,
                count: count
            };
        }

        // ì»¨íˆ¬ì–´ í”Œë¡¯ (MLê³¼ LTO í‘œë©´ ë¶„ë¦¬ í‘œì‹œ)
        function plotContour(data, colormap) {
            document.getElementById('plot').parentElement.style.display = 'none';
            document.getElementById('multiViewContainer').style.display = 'block';

            const Rx = parseFloat(document.getElementById('Rx').value);
            const Ry = parseFloat(document.getElementById('Ry').value);
            const h = parseFloat(document.getElementById('h').value);
            const n = parseFloat(document.getElementById('n').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const resolution = parseInt(document.getElementById('resolution').value);
            const ltoThickness = parseFloat(document.getElementById('ltoThickness').value);

            const singleLensData = generateSingleLensSeparatedSurfaces(Rx, Ry, h, n, alpha, resolution, Rx * 1.5, Ry * 1.5, ltoThickness);

            // Top View (MLê³¼ LTO ë“±ê³ ì„ )
            const mlTrace = {
                x: data.x,
                y: data.y[0],
                z: data.mlSurface,
                type: 'contour',
                colorscale: 'Blues',
                showscale: true,
                name: 'ML Surface',
                contours: {
                    showlines: true,
                    coloring: 'lines'
                }
            };

            const ltoTrace = {
                x: data.x,
                y: data.y[0],
                z: data.ltoSurface,
                type: 'contour',
                colorscale: 'Reds',
                showscale: true,
                name: 'LTO Surface',
                contours: {
                    showlines: true,
                    coloring: 'lines'
                }
            };

            const topLayout = {
                title: 'Top View (ML: íŒŒë‘, LTO: ë¹¨ê°•)',
                xaxis: { title: 'X (Î¼m)' },
                yaxis: { title: 'Y (Î¼m)', scaleanchor: 'x' },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };

            // Side Views - MLê³¼ LTO í”„ë¡œíŒŒì¼ í•¨ê»˜ í‘œì‹œ
            const centerYIndex = Math.floor(singleLensData.y[0].length / 2);
            const centerXIndex = Math.floor(singleLensData.x.length / 2);

            // XZ View
            const xzTraceML = {
                x: singleLensData.x,
                y: singleLensData.mlSurface.map(row => row[centerYIndex]),
                type: 'scatter',
                mode: 'lines',
                name: 'ML Surface',
                line: { color: 'blue', width: 3 }
            };

            const xzTraceLTO = {
                x: singleLensData.x,
                y: singleLensData.ltoSurface.map(row => row[centerYIndex]),
                type: 'scatter',
                mode: 'lines',
                name: 'LTO Surface',
                line: { color: 'red', width: 2 }
            };

            const xzLayout = {
                title: 'Side View XZ (ML: íŒŒë‘, LTO: ë¹¨ê°•)',
                xaxis: { title: 'X (Î¼m)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Î¼m)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };

            // YZ View
            const yzTraceML = {
                x: singleLensData.y[0],
                y: singleLensData.mlSurface[centerXIndex],
                type: 'scatter',
                mode: 'lines',
                name: 'ML Surface',
                line: { color: 'blue', width: 3 }
            };

            const yzTraceLTO = {
                x: singleLensData.y[0],
                y: singleLensData.ltoSurface[centerXIndex],
                type: 'scatter',
                mode: 'lines',
                name: 'LTO Surface',
                line: { color: 'red', width: 2 }
            };

            const yzLayout = {
                title: 'Side View YZ (ML: íŒŒë‘, LTO: ë¹¨ê°•)',
                xaxis: { title: 'Y (Î¼m)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Î¼m)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };

            // Diagonal View
            const diagonalML = [];
            const diagonalLTO = [];
            const diagonalX = [];
            const minSize = Math.min(singleLensData.x.length, singleLensData.y[0].length);

            for (let i = 0; i < minSize; i++) {
                const xVal = singleLensData.x[i] * Math.sqrt(2);
                const mlVal = singleLensData.mlSurface[i][i];
                const ltoVal = singleLensData.ltoSurface[i][i];
                diagonalX.push(xVal);
                diagonalML.push(mlVal);
                diagonalLTO.push(ltoVal);
            }

            const diagTraceML = {
                x: diagonalX,
                y: diagonalML,
                type: 'scatter',
                mode: 'lines',
                name: 'ML Surface',
                line: { color: 'blue', width: 3 }
            };

            const diagTraceLTO = {
                x: diagonalX,
                y: diagonalLTO,
                type: 'scatter',
                mode: 'lines',
                name: 'LTO Surface',
                line: { color: 'red', width: 2 }
            };

            const diagLayout = {
                title: 'Diagonal View (ML: íŒŒë‘, LTO: ë¹¨ê°•)',
                xaxis: { title: 'Diagonal (Î¼m)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Î¼m)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };

            Plotly.newPlot('subView1', [mlTrace, ltoTrace], topLayout);
            Plotly.newPlot('subView2', [diagTraceML, diagTraceLTO], diagLayout);
            Plotly.newPlot('subView3', [xzTraceML, xzTraceLTO], xzLayout);
            Plotly.newPlot('subView4', [yzTraceML, yzTraceLTO], yzLayout);
        }

        // 2D ë“±ê³ ì„  í”Œë¡¯ (MLê³¼ LTO í‘œë©´ ë¶„ë¦¬ í‘œì‹œ)
        function plot2D(data, colormap) {
            document.getElementById('plot').parentElement.style.display = 'none';
            document.getElementById('multiViewContainer').style.display = 'block';

            const Rx = parseFloat(document.getElementById('Rx').value);
            const Ry = parseFloat(document.getElementById('Ry').value);
            const h = parseFloat(document.getElementById('h').value);
            const n = parseFloat(document.getElementById('n').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const resolution = parseInt(document.getElementById('resolution').value);
            const ltoThickness = parseFloat(document.getElementById('ltoThickness').value);

            const singleLensData = generateSingleLensSeparatedSurfaces(Rx, Ry, h, n, alpha, resolution, Rx * 1.5, Ry * 1.5, ltoThickness);

            // Top View (MLê³¼ LTO ë“±ê³ ì„  ì±„ì›€)
            const mlTrace = {
                x: data.x,
                y: data.y[0],
                z: data.mlSurface,
                type: 'contour',
                colorscale: 'Blues',
                showscale: true,
                name: 'ML Surface',
                contours: {
                    showlines: true,
                    coloring: 'fill'
                },
                opacity: 0.7
            };

            const ltoTrace = {
                x: data.x,
                y: data.y[0],
                z: data.ltoSurface,
                type: 'contour',
                colorscale: 'Reds',
                showscale: true,
                name: 'LTO Surface',
                contours: {
                    showlines: true,
                    coloring: 'fill'
                },
                opacity: 0.5
            };

            const topLayout = {
                title: 'Top View ë“±ê³ ì„  (ML: íŒŒë‘, LTO: ë¹¨ê°•)',
                xaxis: { title: 'X (Î¼m)' },
                yaxis: { title: 'Y (Î¼m)', scaleanchor: 'x' },
                margin: { l: 50, r: 50, t: 50, b: 50 }
            };

            // Side Viewsì™€ Diagonal ViewëŠ” ì»¨íˆ¬ì–´ì™€ ë™ì¼
            const centerYIndex = Math.floor(singleLensData.y[0].length / 2);
            const centerXIndex = Math.floor(singleLensData.x.length / 2);

            const xzTraceML = {
                x: singleLensData.x,
                y: singleLensData.mlSurface.map(row => row[centerYIndex]),
                type: 'scatter',
                mode: 'lines',
                name: 'ML Surface',
                line: { color: 'blue', width: 3 }
            };

            const xzTraceLTO = {
                x: singleLensData.x,
                y: singleLensData.ltoSurface.map(row => row[centerYIndex]),
                type: 'scatter',
                mode: 'lines',
                name: 'LTO Surface',
                line: { color: 'red', width: 2 }
            };

            const yzTraceML = {
                x: singleLensData.y[0],
                y: singleLensData.mlSurface[centerXIndex],
                type: 'scatter',
                mode: 'lines',
                name: 'ML Surface',
                line: { color: 'blue', width: 3 }
            };

            const yzTraceLTO = {
                x: singleLensData.y[0],
                y: singleLensData.ltoSurface[centerXIndex],
                type: 'scatter',
                mode: 'lines',
                name: 'LTO Surface',
                line: { color: 'red', width: 2 }
            };

            // Diagonal View
            const diagonalML = [];
            const diagonalLTO = [];
            const diagonalX = [];
            const minSize = Math.min(singleLensData.x.length, singleLensData.y[0].length);

            for (let i = 0; i < minSize; i++) {
                const xVal = singleLensData.x[i] * Math.sqrt(2);
                const mlVal = singleLensData.mlSurface[i][i];
                const ltoVal = singleLensData.ltoSurface[i][i];
                diagonalX.push(xVal);
                diagonalML.push(mlVal);
                diagonalLTO.push(ltoVal);
            }

            const diagTraceML = {
                x: diagonalX,
                y: diagonalML,
                type: 'scatter',
                mode: 'lines',
                name: 'ML Surface',
                line: { color: 'blue', width: 3 }
            };

            const diagTraceLTO = {
                x: diagonalX,
                y: diagonalLTO,
                type: 'scatter',
                mode: 'lines',
                name: 'LTO Surface',
                line: { color: 'red', width: 2 }
            };

            Plotly.newPlot('subView1', [mlTrace, ltoTrace], topLayout);
            Plotly.newPlot('subView2', [diagTraceML, diagTraceLTO], {
                title: 'Diagonal View (ML: íŒŒë‘, LTO: ë¹¨ê°•)',
                xaxis: { title: 'Diagonal (Î¼m)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Î¼m)', scaleratio: 1 }
            });
            Plotly.newPlot('subView3', [xzTraceML, xzTraceLTO], {
                title: 'Side View XZ (ML: íŒŒë‘, LTO: ë¹¨ê°•)',
                xaxis: { title: 'X (Î¼m)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Î¼m)', scaleratio: 1 }
            });
            Plotly.newPlot('subView4', [yzTraceML, yzTraceLTO], {
                title: 'Side View YZ (ML: íŒŒë‘, LTO: ë¹¨ê°•)',
                xaxis: { title: 'Y (Î¼m)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Î¼m)', scaleratio: 1 }
            });
        }

        // 3D ì„œí”¼ìŠ¤ í”Œë¡¯ (MLê³¼ LTO í‘œë©´ í•¨ê»˜)
        function plot3D(data, colormap) {
            document.getElementById('multiViewContainer').style.display = 'none';
            document.getElementById('plot').parentElement.style.display = 'block';

            // ML í‘œë©´
            const mlTrace = {
                x: data.x,
                y: data.y[0],
                z: data.mlSurface,
                type: 'surface',
                colorscale: 'Blues',
                showscale: true,
                name: 'ML Surface',
                opacity: 0.8,
                colorbar: {
                    title: 'ML ë†’ì´ (Î¼m)',
                    x: 0.9
                }
            };

            // LTO í‘œë©´
            const ltoTrace = {
                x: data.x,
                y: data.y[0],
                z: data.ltoSurface,
                type: 'surface',
                colorscale: 'Reds',
                showscale: true,
                name: 'LTO Surface',
                opacity: 0.6,
                colorbar: {
                    title: 'LTO ë†’ì´ (Î¼m)',
                    x: 1.0
                }
            };

            const layout = {
                title: '3D ì„œí”¼ìŠ¤ ë·° - ML (íŒŒë‘) + LTO (ë¹¨ê°•)',
                scene: {
                    xaxis: { title: 'X ì¢Œí‘œ (Î¼m)' },
                    yaxis: { title: 'Y ì¢Œí‘œ (Î¼m)' },
                    zaxis: { title: 'Z ì¢Œí‘œ (ë†’ì´, Î¼m)' },
                    aspectmode: 'data'
                }
            };

            Plotly.newPlot('plot', [mlTrace, ltoTrace], layout);
        }

        // 2D ê´‘ì„  ì¶”ì  í”Œë¡¯ (ê°œì„ ëœ êµ´ì ˆ í¬í•¨)
        function plotRay2D(data, colormap) {
            document.getElementById('plot').parentElement.style.display = 'none';
            document.getElementById('multiViewContainer').style.display = 'block';

            const config = document.getElementById('arrayConfig').value;
            const [rows, cols] = config.split('x').map(Number);
            const Rx = parseFloat(document.getElementById('Rx').value);
            const Ry = parseFloat(document.getElementById('Ry').value);
            const h = parseFloat(document.getElementById('h').value);
            const n = parseFloat(document.getElementById('n').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const numRays = parseInt(document.getElementById('numRays').value);
            const refractiveIndex = parseFloat(document.getElementById('refractiveIndex').value);
            const propagationDistance = parseFloat(document.getElementById('propagationDistance').value);
            const raySpacing = parseFloat(document.getElementById('raySpacing').value);
            const spacingX = parseFloat(document.getElementById('spacingX').value);
            const spacingY = parseFloat(document.getElementById('spacingY').value);
            const ltoThickness = parseFloat(document.getElementById('ltoThickness').value);
            const ltoRefractiveIndex = parseFloat(document.getElementById('ltoRefractiveIndex').value);
            const incidenceTheta = parseFloat(document.getElementById('incidenceTheta').value);
            const incidencePhi = parseFloat(document.getElementById('incidencePhi').value);

            // ì‚¬ê´‘ ì…ì‚¬ ë°©í–¥ ê³„ì‚°
            const incidentDirection = calculateIncidentDirection(incidenceTheta, incidencePhi);

            // Xì¶• ë·°
            const tracesX = [];
            const endPointsX = [];

            // ë Œì¦ˆ í”„ë¡œíŒŒì¼ ê·¸ë¦¬ê¸° (MLê³¼ LTO ëª¨ë‘)
            for (let lensCol = 0; lensCol < cols; lensCol++) {
                const lensCenterX = (lensCol - (cols - 1) / 2) * spacingX;
                const lensXML = [], lensZML = [];
                const lensXLTO = [], lensZLTO = [];

                for (let x = lensCenterX - Rx * 1.2; x <= lensCenterX + Rx * 1.2; x += 0.05) {
                    const localX = x - lensCenterX;
                    const r = Math.abs(localX / Rx);
                    if (r <= 1) {
                        const mlZ = h * Math.pow(1 - r * r, 1 / (2 * alpha));
                        const ltoZ = mlZ + ltoThickness;

                        lensXML.push(x);
                        lensZML.push(mlZ);
                        lensXLTO.push(x);
                        lensZLTO.push(ltoZ);
                    }
                }

                tracesX.push({
                    x: lensXML,
                    y: lensZML,
                    type: 'scatter',
                    mode: 'lines',
                    name: `ML ${lensCol+1}`,
                    line: { color: 'blue', width: 3 },
                    showlegend: false
                });

                tracesX.push({
                    x: lensXLTO,
                    y: lensZLTO,
                    type: 'scatter',
                    mode: 'lines',
                    name: `LTO ${lensCol+1}`,
                    line: { color: 'red', width: 2 },
                    showlegend: false
                });
            }

            // Xì¶• ê´‘ì„  ì¶”ì 
            const colors = ['green', 'orange', 'purple', 'brown', 'pink', 'gray', 'cyan', 'magenta'];
            let rayIndex = 0;

            const totalWidth = cols * spacingX;
            const rayStep = totalWidth * raySpacing / numRays;

            for (let i = 0; i < numRays; i++) {
                const targetX = (i - (numRays-1)/2) * rayStep; // ë Œì¦ˆì— ë„ë‹¬í•  ëª©í‘œ X ìœ„ì¹˜

                // ì‚¬ê´‘ ì…ì‚¬ë¥¼ ê³ ë ¤í•œ ì‹¤ì œ ì‹œì‘ì  ê³„ì‚°
                const startHeight = h + ltoThickness + 0.1;
                const startPos = calculateStartPosition(targetX, 0, incidentDirection, startHeight);

                const rayResult = traceRayThroughLensArray(startPos.startX, startPos.startY, config, spacingX, 0, Rx, Ry, h, n, alpha, refractiveIndex, propagationDistance, ltoThickness, ltoRefractiveIndex, incidentDirection);

                const rayX = rayResult.path.map(p => p.x);
                const rayZ = rayResult.path.map(p => p.z);

                tracesX.push({
                    x: rayX,
                    y: rayZ,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: `ê´‘ì„  ${rayIndex+1}`,
                    line: { color: colors[rayIndex % colors.length], width: 2 },
                    marker: { size: 4 },
                    showlegend: false
                });

                if (rayResult.focused) {
                    endPointsX.push(rayResult);
                }
                rayIndex++;
            }

            // Yì¶• ë·° (ë™ì¼í•œ ë°©ì‹)
            const tracesY = [];
            const endPointsY = [];

            for (let lensRow = 0; lensRow < rows; lensRow++) {
                const lensCenterY = (lensRow - (rows - 1) / 2) * spacingY;
                const lensYML = [], lensZML = [];
                const lensYLTO = [], lensZLTO = [];

                for (let y = lensCenterY - Ry * 1.2; y <= lensCenterY + Ry * 1.2; y += 0.05) {
                    const localY = y - lensCenterY;
                    const r = Math.abs(localY / Ry);
                    if (r <= 1) {
                        const mlZ = h * Math.pow(1 - r * r, 1 / (2 * alpha));
                        const ltoZ = mlZ + ltoThickness;

                        lensYML.push(y);
                        lensZML.push(mlZ);
                        lensYLTO.push(y);
                        lensZLTO.push(ltoZ);
                    }
                }

                tracesY.push({
                    x: lensYML,
                    y: lensZML,
                    type: 'scatter',
                    mode: 'lines',
                    name: `ML ${lensRow+1}`,
                    line: { color: 'blue', width: 3 },
                    showlegend: false
                });

                tracesY.push({
                    x: lensYLTO,
                    y: lensZLTO,
                    type: 'scatter',
                    mode: 'lines',
                    name: `LTO ${lensRow+1}`,
                    line: { color: 'red', width: 2 },
                    showlegend: false
                });
            }

            rayIndex = 0;
            const totalHeight = rows * spacingY;
            const rayStepY = totalHeight * raySpacing / numRays;

            for (let i = 0; i < numRays; i++) {
                const targetY = (i - (numRays-1)/2) * rayStepY; // ë Œì¦ˆì— ë„ë‹¬í•  ëª©í‘œ Y ìœ„ì¹˜

                // ì‚¬ê´‘ ì…ì‚¬ë¥¼ ê³ ë ¤í•œ ì‹¤ì œ ì‹œì‘ì  ê³„ì‚°
                const startHeight = h + ltoThickness + 0.1;
                const startPos = calculateStartPosition(0, targetY, incidentDirection, startHeight);

                const rayResult = traceRayThroughLensArray(startPos.startX, startPos.startY, config, 0, spacingY, Rx, Ry, h, n, alpha, refractiveIndex, propagationDistance, ltoThickness, ltoRefractiveIndex, incidentDirection);

                const rayY = rayResult.path.map(p => p.y);
                const rayZ = rayResult.path.map(p => p.z);

                tracesY.push({
                    x: rayY,
                    y: rayZ,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: `ê´‘ì„  ${rayIndex+1}`,
                    line: { color: colors[rayIndex % colors.length], width: 2 },
                    marker: { size: 4 },
                    showlegend: false
                });

                if (rayResult.focused) {
                    endPointsY.push(rayResult);
                }
                rayIndex++;
            }

            // Diagonal ë·°
            const tracesDiag = [];
            const endPointsDiag = [];

            // ëŒ€ê°ì„  ë°©í–¥ ë Œì¦ˆ í”„ë¡œíŒŒì¼ ê·¸ë¦¬ê¸°
            for (let lensRow = 0; lensRow < rows; lensRow++) {
                for (let lensCol = 0; lensCol < cols; lensCol++) {
                    if (lensRow !== lensCol) continue;
                    const lensCenterX = (lensCol - (cols - 1) / 2) * spacingX;
                    const lensCenterY = (lensRow - (rows - 1) / 2) * spacingY;
                    const lensCenterDiag = (lensCenterX + lensCenterY) / Math.sqrt(2);

                    const lensML = [], lensLTO = [], lensDiag = [];

                    // ëŒ€ê°ì„  ë°©í–¥ìœ¼ë¡œ ë Œì¦ˆ í”„ë¡œíŒŒì¼ ìƒì„±
                    const maxRadius = Math.max(Rx, Ry);
                    for (let d = lensCenterDiag - maxRadius * 1.2; d <= lensCenterDiag + maxRadius * 1.2; d += 0.05) {
                        // ëŒ€ê°ì„  ì¢Œí‘œë¥¼ X, Y ì¢Œí‘œë¡œ ë³€í™˜
                        const localX = (d - lensCenterDiag) / Math.sqrt(2);
                        const localY = (d - lensCenterDiag) / Math.sqrt(2);

                        const r = superellipseDistance(localX, localY, Rx, Ry, n);
                        if (r <= 1) {
                            const mlZ = h * Math.pow(1 - r * r, 1 / (2 * alpha));
                            const ltoZ = mlZ + ltoThickness;

                            lensDiag.push(d);
                            lensML.push(mlZ);
                            lensLTO.push(ltoZ);
                        }
                    }

                    if (lensDiag.length > 0) {
                        tracesDiag.push({
                            x: lensDiag,
                            y: lensML,
                            type: 'scatter',
                            mode: 'lines',
                            name: `ML ${lensRow+1}-${lensCol+1}`,
                            line: { color: 'blue', width: 3 },
                            showlegend: false
                        });

                        tracesDiag.push({
                            x: lensDiag,
                            y: lensLTO,
                            type: 'scatter',
                            mode: 'lines',
                            name: `LTO ${lensRow+1}-${lensCol+1}`,
                            line: { color: 'red', width: 2 },
                            showlegend: false
                        });
                    }
                }
            }

            // ëŒ€ê°ì„  ê´‘ì„  ì¶”ì 
            const maxDiag = Math.max(totalWidth, totalHeight);
            const rayStepDiag = maxDiag * raySpacing / numRays;

            rayIndex = 0;
            for (let i = 0; i < numRays; i++) {
                const targetDiag = (i - (numRays-1)/2) * rayStepDiag;
                const targetX = targetDiag / Math.sqrt(2);
                const targetY = targetDiag / Math.sqrt(2);

                // ì‚¬ê´‘ ì…ì‚¬ë¥¼ ê³ ë ¤í•œ ì‹¤ì œ ì‹œì‘ì  ê³„ì‚°
                const startHeight = h + ltoThickness + 0.1;
                const startPos = calculateStartPosition(targetX, targetY, incidentDirection, startHeight);

                const rayResult = traceRayThroughLensArray(startPos.startX, startPos.startY, config, spacingX, spacingY, Rx, Ry, h, n, alpha, refractiveIndex, propagationDistance, ltoThickness, ltoRefractiveIndex, incidentDirection);

                const rayDiag = rayResult.path.map(p => (p.x + p.y) / Math.sqrt(2));
                const rayZ = rayResult.path.map(p => p.z);

                tracesDiag.push({
                    x: rayDiag,
                    y: rayZ,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: `ëŒ€ê°ì„  ê´‘ì„  ${rayIndex+1}`,
                    line: { color: colors[rayIndex % colors.length], width: 2 },
                    marker: { size: 4 },
                    showlegend: false
                });

                if (rayResult.focused) {
                    endPointsDiag.push(rayResult);
                }
                rayIndex++;
            }

            // ì§‘ì†ì  ê³„ì‚°
            const focalPointX = calculateFocalPoint(endPointsX);
            const focalPointY = calculateFocalPoint(endPointsY);
            const focalPointDiag = calculateFocalPoint(endPointsDiag);

            let focalInfoX = "ì§‘ì†ì  ì—†ìŒ";
            let focalInfoY = "ì§‘ì†ì  ì—†ìŒ";
            let focalInfoDiag = "ì§‘ì†ì  ì—†ìŒ";

            if (focalPointX) {
                focalInfoX = `X: ${focalPointX.x.toFixed(3)}Î¼m, Z: ${focalPointX.z.toFixed(3)}Î¼m (${focalPointX.count}ê°œ ê´‘ì„ )`;
            }

            if (focalPointY) {
                focalInfoY = `Y: ${focalPointY.y.toFixed(3)}Î¼m, Z: ${focalPointY.z.toFixed(3)}Î¼m (${focalPointY.count}ê°œ ê´‘ì„ )`;
            }

            if (focalPointDiag) {
                const diagPos = (focalPointDiag.x + focalPointDiag.y) / Math.sqrt(2);
                focalInfoDiag = `D: ${diagPos.toFixed(3)}Î¼m, Z: ${focalPointDiag.z.toFixed(3)}Î¼m (${focalPointDiag.count}ê°œ ê´‘ì„ )`;
            }

            Plotly.newPlot('subView1', tracesDiag, {
                title: `Diagonal ë·° - ML(íŒŒë‘) + LTO(ë¹¨ê°•) + ê´‘ì„ ì¶”ì  (Î¸=${incidenceTheta}Â°, Ï†=${incidencePhi}Â°)<br><span style="font-size:12px">ì§‘ì†ì : ${focalInfoDiag}</span>`,
                xaxis: { title: 'Diagonal (Î¼m)', scaleanchor: 'y' },
                yaxis: { title: 'Z (Î¼m)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 80, b: 50 }
            });

            Plotly.newPlot('subView2', tracesX, {
                title: `Xì¶• ë·° - ML(íŒŒë‘) + LTO(ë¹¨ê°•) + ê´‘ì„ ì¶”ì  (Î¸=${incidenceTheta}Â°, Ï†=${incidencePhi}Â°)<br><span style="font-size:12px">ì§‘ì†ì : ${focalInfoX}</span>`,
                xaxis: { title: 'X ì¢Œí‘œ (Î¼m)', scaleanchor: 'y' },
                yaxis: { title: 'Z ì¢Œí‘œ (Î¼m)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 80, b: 50 }
            });

            Plotly.newPlot('subView3', tracesY, {
                title: `Yì¶• ë·° - ML(íŒŒë‘) + LTO(ë¹¨ê°•) + ê´‘ì„ ì¶”ì  (Î¸=${incidenceTheta}Â°, Ï†=${incidencePhi}Â°)<br><span style="font-size:12px">ì§‘ì†ì : ${focalInfoY}</span>`,
                xaxis: { title: 'Y ì¢Œí‘œ (Î¼m)', scaleanchor: 'y' },
                yaxis: { title: 'Z ì¢Œí‘œ (Î¼m)', scaleratio: 1 },
                margin: { l: 50, r: 50, t: 80, b: 50 }
            });

            Plotly.newPlot('subView4', [], {
                title: 'êµ´ì ˆ ì •ë³´',
                annotations: [{
                    text: `ê³µê¸°(n=1.0) â†’ LTO(n=${ltoRefractiveIndex}) â†’ ë Œì¦ˆ(n=${refractiveIndex}) â†’ MLê¸°íŒ(n=${refractiveIndex})<br>LTO ë‘ê»˜: ${ltoThickness.toFixed(3)}Î¼m<br>ì…ì‚¬ê°: Î¸=${incidenceTheta}Â°, Ï†=${incidencePhi}Â°`,
                    xref: 'paper', yref: 'paper', x: 0.5, y: 0.5, showarrow: false,
                    font: { size: 14 }, align: 'center'
                }]
            });
        }

        // 3D ê´‘ì„  ì¶”ì  í”Œë¡¯ (MLê³¼ LTO í‘œë©´ + ê°œì„ ëœ êµ´ì ˆ)
        function plotRay3D(data, colormap) {
            document.getElementById('multiViewContainer').style.display = 'none';
            document.getElementById('plot').parentElement.style.display = 'block';

            const config = document.getElementById('arrayConfig').value;
            const [rows, cols] = config.split('x').map(Number);
            const Rx = parseFloat(document.getElementById('Rx').value);
            const Ry = parseFloat(document.getElementById('Ry').value);
            const h = parseFloat(document.getElementById('h').value);
            const n = parseFloat(document.getElementById('n').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const numRays = parseInt(document.getElementById('numRays').value);
            const refractiveIndex = parseFloat(document.getElementById('refractiveIndex').value);
            const propagationDistance = parseFloat(document.getElementById('propagationDistance').value);
            const raySpacing = parseFloat(document.getElementById('raySpacing').value);
            const spacingX = parseFloat(document.getElementById('spacingX').value);
            const spacingY = parseFloat(document.getElementById('spacingY').value);
            const ltoThickness = parseFloat(document.getElementById('ltoThickness').value);
            const ltoRefractiveIndex = parseFloat(document.getElementById('ltoRefractiveIndex').value);
            const incidenceTheta = parseFloat(document.getElementById('incidenceTheta').value);
            const incidencePhi = parseFloat(document.getElementById('incidencePhi').value);

            // ì‚¬ê´‘ ì…ì‚¬ ë°©í–¥ ê³„ì‚°
            const incidentDirection = calculateIncidentDirection(incidenceTheta, incidencePhi);

            const traces = [];
            const allEndPoints = [];

            // ML í‘œë©´
            traces.push({
                x: data.x,
                y: data.y[0],
                z: data.mlSurface,
                type: 'surface',
                colorscale: 'Blues',
                opacity: 0.6,
                showscale: false,
                name: 'ML Surface'
            });

            // LTO í‘œë©´
            traces.push({
                x: data.x,
                y: data.y[0],
                z: data.ltoSurface,
                type: 'surface',
                colorscale: 'Reds',
                opacity: 0.4,
                showscale: false,
                name: 'LTO Surface'
            });

            // ê´‘ì„  ì¶”ì 
            const colors = ['green', 'orange', 'purple', 'brown', 'pink', 'yellow', 'cyan', 'magenta'];
            let rayIndex = 0;

            const totalWidth = cols * spacingX;
            const totalHeight = rows * spacingY;
            const raysPerSide = Math.round(Math.sqrt(numRays));

            const rayStepX = totalWidth * raySpacing / (raysPerSide - 1);
            const rayStepY = totalHeight * raySpacing / (raysPerSide - 1);

            for (let i = 0; i < raysPerSide; i++) {
                for (let j = 0; j < raysPerSide; j++) {
                    const targetX = (i - (raysPerSide-1)/2) * rayStepX; // ë Œì¦ˆì— ë„ë‹¬í•  ëª©í‘œ ìœ„ì¹˜
                    const targetY = (j - (raysPerSide-1)/2) * rayStepY;

                    // ì‚¬ê´‘ ì…ì‚¬ë¥¼ ê³ ë ¤í•œ ì‹¤ì œ ì‹œì‘ì  ê³„ì‚°
                    const startHeight = h + ltoThickness + 0.1;
                    const startPos = calculateStartPosition(targetX, targetY, incidentDirection, startHeight);

                    const rayResult = traceRayThroughLensArray(
                        startPos.startX, startPos.startY, config, spacingX, spacingY,
                        Rx, Ry, h, n, alpha, refractiveIndex, propagationDistance, ltoThickness, ltoRefractiveIndex, incidentDirection
                    );

                    const rayX = rayResult.path.map(p => p.x);
                    const rayY = rayResult.path.map(p => p.y);
                    const rayZ = rayResult.path.map(p => p.z);

                    traces.push({
                        x: rayX,
                        y: rayY,
                        z: rayZ,
                        type: 'scatter3d',
                        mode: 'lines+markers',
                        name: `ê´‘ì„  ${rayIndex+1}`,
                        line: { color: colors[rayIndex % colors.length], width: 4 },
                        marker: { size: 3 },
                        showlegend: false
                    });

                    if (rayResult.focused) {
                        allEndPoints.push(rayResult);
                    }

                    rayIndex++;
                    if (rayIndex >= 50) break;
                }
                if (rayIndex >= 50) break;
            }

            // ì§‘ì†ì  ê³„ì‚° ë° í‘œì‹œ
            const globalFocalPoint = calculateFocalPoint(allEndPoints);
            let focalInfo = "ì§‘ì†ì  ì •ë³´ ì—†ìŒ";

            if (globalFocalPoint) {
                focalInfo = `ì§‘ì†ì : (${globalFocalPoint.x.toFixed(3)}, ${globalFocalPoint.y.toFixed(3)}, ${globalFocalPoint.z.toFixed(3)}) Î¼m | ${globalFocalPoint.count}ê°œ ê´‘ì„  ì§‘ì†`;

                traces.push({
                    x: [globalFocalPoint.x],
                    y: [globalFocalPoint.y],
                    z: [globalFocalPoint.z],
                    type: 'scatter3d',
                    mode: 'markers',
                    name: 'ì§‘ì†ì ',
                    marker: {
                        size: 15,
                        color: 'red',
                        symbol: 'diamond'
                    },
                    showlegend: true
                });
            }

            const layout = {
                title: `3D ê´‘ì„  ì¶”ì  - ML(íŒŒë‘) + LTO(ë¹¨ê°•) + ì‚¬ê´‘ì…ì‚¬ (Î¸=${incidenceTheta}Â°, Ï†=${incidencePhi}Â°)<br><span style="font-size:12px">${focalInfo}</span>`,
                scene: {
                    xaxis: { title: 'X (Î¼m)' },
                    yaxis: { title: 'Y (Î¼m)' },
                    zaxis: { title: 'Z (Î¼m)' },
                    aspectmode: 'data'
                },
                showlegend: true
            };

            Plotly.newPlot('plot', traces, layout);
        }

        // ì„¤ì • ê´€ë ¨ í•¨ìˆ˜ë“¤
        async function copyConfigurationToClipboard() {
            const config = {
                arrayConfig: document.getElementById('arrayConfig').value,
                spacingX: parseFloat(document.getElementById('spacingX').value),
                spacingY: parseFloat(document.getElementById('spacingY').value),
                Rx: parseFloat(document.getElementById('Rx').value),
                Ry: parseFloat(document.getElementById('Ry').value),
                h: parseFloat(document.getElementById('h').value),
                n: parseFloat(document.getElementById('n').value),
                alpha: parseFloat(document.getElementById('alpha').value),
                resolution: parseInt(document.getElementById('resolution').value),
                colormap: document.getElementById('colormap').value,
                numRays: parseInt(document.getElementById('numRays').value),
                refractiveIndex: parseFloat(document.getElementById('refractiveIndex').value),
                propagationDistance: parseFloat(document.getElementById('propagationDistance').value),
                raySpacing: parseFloat(document.getElementById('raySpacing').value),
                ltoThickness: parseFloat(document.getElementById('ltoThickness').value),
                ltoRefractiveIndex: parseFloat(document.getElementById('ltoRefractiveIndex').value),
                incidenceTheta: parseFloat(document.getElementById('incidenceTheta').value),
                incidencePhi: parseFloat(document.getElementById('incidencePhi').value),
                exportDate: new Date().toISOString(),
                version: '2.3'
            };

            const configText = JSON.stringify(config, null, 2);

            try {
                await navigator.clipboard.writeText(configText);
                document.getElementById('configTextarea').value = configText;

                const button = event.target;
                const originalText = button.textContent;
                button.textContent = 'âœ… ë³µì‚¬ë¨!';
                button.style.background = '#27ae60';

                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 2000);

            } catch (err) {
                document.getElementById('configTextarea').value = configText;
                document.getElementById('configTextarea').select();
                alert('ì„¤ì •ì´ í…ìŠ¤íŠ¸ ì˜ì—­ì— í‘œì‹œë˜ì—ˆìŠµë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ë³µì‚¬í•´ì£¼ì„¸ìš”.');
            }
        }

        function applyConfiguration() {
            const configText = document.getElementById('configTextarea').value.trim();

            if (!configText) {
                alert('ì„¤ì • í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                const config = JSON.parse(configText);

                if (config.arrayConfig) document.getElementById('arrayConfig').value = config.arrayConfig;
                if (config.spacingX !== undefined) {
                    document.getElementById('spacingX').value = config.spacingX;
                    updateValueDisplay('spacingX', config.spacingX);
                }
                if (config.spacingY !== undefined) {
                    document.getElementById('spacingY').value = config.spacingY;
                    updateValueDisplay('spacingY', config.spacingY);
                }
                if (config.Rx !== undefined) {
                    document.getElementById('Rx').value = config.Rx;
                    updateValueDisplay('Rx', config.Rx);
                }
                if (config.Ry !== undefined) {
                    document.getElementById('Ry').value = config.Ry;
                    updateValueDisplay('Ry', config.Ry);
                }
                if (config.h !== undefined) {
                    document.getElementById('h').value = config.h;
                    updateValueDisplay('h', config.h);
                }
                if (config.n !== undefined) {
                    document.getElementById('n').value = config.n;
                    updateValueDisplay('n', config.n);
                }
                if (config.alpha !== undefined) {
                    document.getElementById('alpha').value = config.alpha;
                    updateValueDisplay('alpha', config.alpha);
                }
                if (config.resolution !== undefined) {
                    document.getElementById('resolution').value = config.resolution;
                    updateValueDisplay('resolution', config.resolution);
                }
                if (config.colormap) document.getElementById('colormap').value = config.colormap;
                if (config.numRays !== undefined) {
                    document.getElementById('numRays').value = config.numRays;
                    updateValueDisplay('numRays', config.numRays);
                }
                if (config.refractiveIndex !== undefined) {
                    document.getElementById('refractiveIndex').value = config.refractiveIndex;
                    updateValueDisplay('refractiveIndex', config.refractiveIndex);
                }
                if (config.propagationDistance !== undefined) {
                    document.getElementById('propagationDistance').value = config.propagationDistance;
                    updateValueDisplay('propagationDistance', config.propagationDistance);
                }
                if (config.raySpacing !== undefined) {
                    document.getElementById('raySpacing').value = config.raySpacing;
                    updateValueDisplay('raySpacing', config.raySpacing);
                }
                if (config.ltoThickness !== undefined) {
                    document.getElementById('ltoThickness').value = config.ltoThickness;
                    updateValueDisplay('ltoThickness', config.ltoThickness);
                }
                if (config.ltoRefractiveIndex !== undefined) {
                    document.getElementById('ltoRefractiveIndex').value = config.ltoRefractiveIndex;
                    updateValueDisplay('ltoRefractiveIndex', config.ltoRefractiveIndex);
                }
                if (config.incidenceTheta !== undefined) {
                    document.getElementById('incidenceTheta').value = config.incidenceTheta;
                    updateValueDisplay('incidenceTheta', config.incidenceTheta);
                }
                if (config.incidencePhi !== undefined) {
                    document.getElementById('incidencePhi').value = config.incidencePhi;
                    updateValueDisplay('incidencePhi', config.incidencePhi);
                }

                updatePlot();

                const button = event.target;
                const originalText = button.textContent;
                button.textContent = 'âœ… ì ìš©ë¨!';
                button.style.background = '#27ae60';

                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 2000);

            } catch (error) {
                alert('ì„¤ì • í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        function resetToDefaults() {
            document.getElementById('arrayConfig').value = '1x1';
            document.getElementById('spacingX').value = 1.0;
            document.getElementById('spacingY').value = 1.0;
            document.getElementById('Rx').value = 0.6;
            document.getElementById('Ry').value = 0.6;
            document.getElementById('h').value = 0.5;
            document.getElementById('n').value = 2.0;
            document.getElementById('alpha').value = 1.0;
            document.getElementById('resolution').value = 50;
            document.getElementById('colormap').value = 'Viridis';
            document.getElementById('numRays').value = 20;
            document.getElementById('refractiveIndex').value = 1.5;
            document.getElementById('propagationDistance').value = 2;
            document.getElementById('raySpacing').value = 0.9;
            document.getElementById('ltoThickness').value = 0.1;
            document.getElementById('ltoRefractiveIndex').value = 1.46;
            document.getElementById('incidenceTheta').value = 0;
            document.getElementById('incidencePhi').value = 0;

            updateValueDisplay('spacingX', 1.0);
            updateValueDisplay('spacingY', 1.0);
            updateValueDisplay('Rx', 0.6);
            updateValueDisplay('Ry', 0.6);
            updateValueDisplay('h', 0.5);
            updateValueDisplay('n', 2.0);
            updateValueDisplay('alpha', 1.0);
            updateValueDisplay('resolution', 50);
            updateValueDisplay('numRays', 20);
            updateValueDisplay('refractiveIndex', 1.5);
            updateValueDisplay('propagationDistance', 2);
            updateValueDisplay('raySpacing', 0.9);
            updateValueDisplay('ltoThickness', 0.1);
            updateValueDisplay('ltoRefractiveIndex', 1.46);
            updateValueDisplay('incidenceTheta', 0);
            updateValueDisplay('incidencePhi', 0);

            updatePlot();
        }

        // ë©”ì¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updatePlot() {
            const config = document.getElementById('arrayConfig').value;
            const Rx = parseFloat(document.getElementById('Rx').value);
            const Ry = parseFloat(document.getElementById('Ry').value);
            const h = parseFloat(document.getElementById('h').value);
            const n = parseFloat(document.getElementById('n').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const resolution = parseInt(document.getElementById('resolution').value);
            const spacingX = parseFloat(document.getElementById('spacingX').value);
            const spacingY = parseFloat(document.getElementById('spacingY').value);
            const colormap = document.getElementById('colormap').value;
            const ltoThickness = parseFloat(document.getElementById('ltoThickness').value);

            const data = generateSeparatedSurfaces(config, Rx, Ry, h, n, alpha, resolution, spacingX, spacingY, ltoThickness);

            switch (currentView) {
                case 'Contour':
                    plotContour(data, colormap);
                    break;
                case '2D':
                    plot2D(data, colormap);
                    break;
                case '3D':
                    plot3D(data, colormap);
                    break;
                case 'Ray2D':
                    plotRay2D(data, colormap);
                    break;
                case 'Ray3D':
                    plotRay3D(data, colormap);
                    break;
            }
        }

        function updateViewButtons() {
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            if (currentView === 'Contour') {
                document.getElementById('viewContour').classList.add('active');
            } else if (currentView === '2D') {
                document.getElementById('view2D').classList.add('active');
            } else if (currentView === '3D') {
                document.getElementById('view3D').classList.add('active');
            } else if (currentView === 'Ray2D') {
                document.getElementById('viewRay2D').classList.add('active');
            } else if (currentView === 'Ray3D') {
                document.getElementById('viewRay3D').classList.add('active');
            }
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        document.addEventListener('DOMContentLoaded', function() {
            // ìŠ¬ë¼ì´ë” ì´ë²¤íŠ¸
            ['Rx', 'Ry', 'h', 'n', 'alpha', 'resolution', 'spacingX', 'spacingY', 'numRays', 'refractiveIndex', 'propagationDistance', 'raySpacing', 'ltoThickness', 'ltoRefractiveIndex', 'incidenceTheta', 'incidencePhi'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', function() {
                        updateValueDisplay(id, this.value);
                        updatePlot();
                    });
                    updateValueDisplay(id, element.value);
                }
            });

            // ì„ íƒ ë°•ìŠ¤ ì´ë²¤íŠ¸
            ['arrayConfig', 'colormap'].forEach(id => {
                document.getElementById(id).addEventListener('change', updatePlot);
            });

            // ë·° ë²„íŠ¼ ì´ë²¤íŠ¸
            document.getElementById('viewContour').addEventListener('click', function() {
                currentView = 'Contour';
                updateViewButtons();
                updatePlot();
            });

            document.getElementById('view2D').addEventListener('click', function() {
                currentView = '2D';
                updateViewButtons();
                updatePlot();
            });

            document.getElementById('view3D').addEventListener('click', function() {
                currentView = '3D';
                updateViewButtons();
                updatePlot();
            });

            document.getElementById('viewRay2D').addEventListener('click', function() {
                currentView = 'Ray2D';
                updateViewButtons();
                updatePlot();
            });

            document.getElementById('viewRay3D').addEventListener('click', function() {
                currentView = 'Ray3D';
                updateViewButtons();
                updatePlot();
            });

            // ì´ˆê¸° í”Œë¡¯ ìƒì„±
            updatePlot();
        });
    </script>
</body>
</html>