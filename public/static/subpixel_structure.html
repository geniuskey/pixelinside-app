<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>서브픽셀 구조 시뮬레이터</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Arial', sans-serif;
            color: #ffffff;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin: 0;
            background: linear-gradient(45deg, #00d4ff, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 1.2em;
            margin: 10px 0;
            opacity: 0.9;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
            margin-bottom: 30px;
        }

        .pixel-display {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .controls {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .pixel-canvas {
            width: 100%;
            height: 500px;
            background: #000;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group h3 {
            margin: 0 0 15px 0;
            font-size: 1.3em;
            color: #00d4ff;
        }

        .slider-container {
            margin: 15px 0;
        }

        .slider-container label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #e0e0e0;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, #333, #666);
            outline: none;
            appearance: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #00d4ff, #ff6b6b);
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #00d4ff, #ff6b6b);
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .value-display {
            text-align: center;
            margin-top: 5px;
            font-size: 0.9em;
            color: #a0a0a0;
        }

        .toggle-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .toggle-btn {
            padding: 8px 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .toggle-btn.active {
            background: linear-gradient(45deg, #00d4ff, #ff6b6b);
            border-color: transparent;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }

        .spectrum-display {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 25px;
            margin-top: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .spectrum-canvas {
            width: 100%;
            height: 200px;
            background: #000;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .info-panel h4 {
            margin: 0 0 10px 0;
            color: #00d4ff;
        }

        .info-panel p {
            margin: 5px 0;
            font-size: 0.9em;
            line-height: 1.4;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>서브픽셀 구조 시뮬레이터</h1>
            <p>이미지 센서의 개별 픽셀 내부 구조와 빛의 상호작용을 시각화</p>
        </div>

        <div class="main-grid">
            <div class="pixel-display">
                <h3>픽셀 단면 구조</h3>
                <canvas id="pixelCanvas" class="pixel-canvas"></canvas>
            </div>

            <div class="controls">
                <div class="control-group">
                    <h3>🔆 입사광 제어</h3>
                    <div class="slider-container">
                        <label>입사각 (°)</label>
                        <input type="range" id="lightAngle" class="slider" min="0" max="45" value="0">
                        <div class="value-display" id="lightAngleValue">0°</div>
                    </div>
                    <div class="slider-container">
                        <label>광량 세기</label>
                        <input type="range" id="lightIntensity" class="slider" min="0" max="100" value="80">
                        <div class="value-display" id="lightIntensityValue">80%</div>
                    </div>
                    <div class="slider-container">
                        <label>파장 (nm)</label>
                        <input type="range" id="wavelength" class="slider" min="400" max="700" value="550">
                        <div class="value-display" id="wavelengthValue">550nm</div>
                    </div>
                </div>

                <div class="control-group">
                    <h3>🔬 구조 요소</h3>
                    <div class="toggle-group">
                        <button class="toggle-btn active" id="microlensBtn">마이크로렌즈</button>
                        <button class="toggle-btn active" id="colorFilterBtn">컬러 필터</button>
                        <button class="toggle-btn active" id="siliconBtn">실리콘 기판</button>
                        <button class="toggle-btn active" id="wiringBtn">배선층</button>
                        <button class="toggle-btn active" id="animateBtn">빛 애니메이션</button>
                    </div>
                </div>

                <div class="info-panel">
                    <h4>실시간 정보</h4>
                    <p>평균 투과율: <span id="transmittance">85%</span></p>
                    <p>집광 효율: <span id="lightGathering">92%</span></p>
                    <p>실리콘 도달률: <span id="reachRate">78%</span></p>
                </div>
            </div>
        </div>

        <div class="spectrum-display">
            <h3>RGB 컬러 필터 투과 스펙트럼</h3>
            <canvas id="spectrumCanvas" class="spectrum-canvas"></canvas>
        </div>
    </div>

    <script>
        class SubPixelSimulator {
            constructor() {
                this.canvas = document.getElementById('pixelCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.spectrumCanvas = document.getElementById('spectrumCanvas');
                this.spectrumCtx = this.spectrumCanvas.getContext('2d');
                
                this.settings = {
                    lightAngle: 0,
                    lightIntensity: 80,
                    wavelength: 550,
                    showMicrolens: true,
                    showColorFilter: true,
                    showSilicon: true,
                    showWiring: true,
                    animateLight: true
                };
                
                this.time = 0;
                this.animationId = null;
                this.photons = [];
                this.electrons = [];
                
                this.setupCanvas();
                this.setupControls();
                this.setupToggleButtons();
                this.startAnimation();
            }
            
            setupCanvas() {
                const canvasRect = this.canvas.getBoundingClientRect();
                this.canvas.width = canvasRect.width * 2;
                this.canvas.height = canvasRect.height * 2;
                this.ctx.scale(2, 2);
                
                const spectrumRect = this.spectrumCanvas.getBoundingClientRect();
                this.spectrumCanvas.width = spectrumRect.width * 2;
                this.spectrumCanvas.height = spectrumRect.height * 2;
                this.spectrumCtx.scale(2, 2);
            }
            
            setupControls() {
                const controls = [
                    { id: 'lightAngle', prop: 'lightAngle', suffix: '°' },
                    { id: 'lightIntensity', prop: 'lightIntensity', suffix: '%' },
                    { id: 'wavelength', prop: 'wavelength', suffix: 'nm' }
                ];
                
                controls.forEach(control => {
                    const slider = document.getElementById(control.id);
                    const display = document.getElementById(control.id + 'Value');
                    
                    slider.addEventListener('input', (e) => {
                        this.settings[control.prop] = parseFloat(e.target.value);
                        display.textContent = e.target.value + control.suffix;
                        
                        if (!this.settings.animateLight) {
                            this.drawPixelStructure();
                        }
                        
                        this.updateInfo();
                        if (control.id === 'wavelength') {
                            this.drawSpectrum();
                        }
                    });
                });
            }
            
            setupToggleButtons() {
                const toggles = [
                    { id: 'microlensBtn', prop: 'showMicrolens' },
                    { id: 'colorFilterBtn', prop: 'showColorFilter' },
                    { id: 'siliconBtn', prop: 'showSilicon' },
                    { id: 'wiringBtn', prop: 'showWiring' },
                    { id: 'animateBtn', prop: 'animateLight' }
                ];
                
                toggles.forEach(toggle => {
                    const btn = document.getElementById(toggle.id);
                    btn.addEventListener('click', (e) => {
                        this.settings[toggle.prop] = !this.settings[toggle.prop];
                        e.target.classList.toggle('active', this.settings[toggle.prop]);
                        
                        if (toggle.id === 'animateBtn') {
                            if (this.settings.animateLight) {
                                this.startContinuousAnimation();
                            } else {
                                this.stopAnimation();
                                this.drawPixelStructure();
                            }
                        } else {
                            this.drawPixelStructure();
                        }
                        this.updateInfo();
                    });
                });
            }
            
            wavelengthToRGB(wavelength) {
                let r, g, b;
                
                if (wavelength >= 400 && wavelength < 410) {
                    r = -(wavelength - 410) / (410 - 400);
                    g = 0;
                    b = 1;
                } else if (wavelength >= 410 && wavelength < 475) {
                    r = 0;
                    g = 0;
                    b = 1;
                } else if (wavelength >= 475 && wavelength < 510) {
                    r = 0;
                    g = (wavelength - 475) / (510 - 475);
                    b = 1;
                } else if (wavelength >= 510 && wavelength < 580) {
                    r = 0;
                    g = 1;
                    b = -(wavelength - 580) / (580 - 510);
                } else if (wavelength >= 580 && wavelength < 645) {
                    r = (wavelength - 580) / (645 - 580);
                    g = 1;
                    b = 0;
                } else if (wavelength >= 645 && wavelength < 700) {
                    r = 1;
                    g = -(wavelength - 700) / (700 - 645);
                    b = 0;
                } else {
                    r = 0;
                    g = 0;
                    b = 0;
                }
                
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }
            
            // 컬러 필터 투과율 계산
            getFilterTransmittance(wavelength, filterType) {
                let peakWavelength, bandwidth;
                
                switch(filterType) {
                    case 'red':
                        peakWavelength = 630;
                        bandwidth = 100;
                        break;
                    case 'green':
                        peakWavelength = 530;
                        bandwidth = 80;
                        break;
                    case 'blue':
                        peakWavelength = 470;
                        bandwidth = 90;
                        break;
                    default:
                        return 0;
                }
                
                const delta = Math.abs(wavelength - peakWavelength);
                const transmittance = Math.exp(-(delta * delta) / (2 * bandwidth * bandwidth / 4));
                return Math.max(0, Math.min(1, transmittance));
            }
            
            updatePhotons(siliconBounds) {
                // 새로운 광자 생성
                if (this.settings.lightIntensity > 0 && Math.random() < 0.3) {
                    const canvasRect = this.canvas.getBoundingClientRect();
                    const width = canvasRect.width;
                    
                    this.photons.push({
                        x: Math.random() * width * 0.8 + width * 0.1,
                        y: -10,
                        vx: Math.sin(this.settings.lightAngle * Math.PI / 180) * 2,
                        vy: 4,
                        energy: this.settings.lightIntensity / 100,
                        wavelength: this.settings.wavelength,
                        life: 1.0
                    });
                }
                
                // 광자 업데이트
                for (let i = this.photons.length - 1; i >= 0; i--) {
                    const photon = this.photons[i];
                    photon.x += photon.vx;
                    photon.y += photon.vy;
                    photon.life -= 0.01;
                    
                    // 실리콘 영역에 도달시 전자 생성
                    if (siliconBounds && 
                        photon.x >= siliconBounds.left && 
                        photon.x <= siliconBounds.right &&
                        photon.y >= siliconBounds.top && 
                        photon.y <= siliconBounds.bottom) {
                        
                        // 광전 변환
                        if (Math.random() < 0.8) {
                            this.electrons.push({
                                x: photon.x,
                                y: photon.y,
                                vx: (Math.random() - 0.5) * 2,
                                vy: (Math.random() - 0.5) * 2,
                                life: 1.0
                            });
                        }
                        
                        this.photons.splice(i, 1);
                        continue;
                    }
                    
                    // 생명력이 다하거나 화면 밖으로 나가면 제거
                    if (photon.life <= 0 || photon.y > 600) {
                        this.photons.splice(i, 1);
                    }
                }
            }
            
            updateElectrons() {
                for (let i = this.electrons.length - 1; i >= 0; i--) {
                    const electron = this.electrons[i];
                    electron.x += electron.vx;
                    electron.y += electron.vy;
                    electron.life -= 0.02;
                    
                    // 감속
                    electron.vx *= 0.98;
                    electron.vy *= 0.98;
                    
                    if (electron.life <= 0) {
                        this.electrons.splice(i, 1);
                    }
                }
            }
            
            renderParticles() {
                // 광자 렌더링
                this.photons.forEach(photon => {
                    const rgb = this.wavelengthToRGB(photon.wavelength);
                    const alpha = photon.life * photon.energy;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(photon.x, photon.y, 3, 0, Math.PI * 2);
                    this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha})`;
                    this.ctx.fill();
                    
                    // 꼬리 효과
                    this.ctx.beginPath();
                    this.ctx.moveTo(photon.x, photon.y);
                    this.ctx.lineTo(photon.x - photon.vx * 3, photon.y - photon.vy * 3);
                    this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha * 0.5})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });
                
                // 전자 렌더링
                this.electrons.forEach(electron => {
                    const alpha = electron.life;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(electron.x, electron.y, 2, 0, Math.PI * 2);
                    this.ctx.fillStyle = `rgba(100, 200, 255, ${alpha})`;
                    this.ctx.fill();
                });
            }
            
            drawPixelStructure() {
                const canvasRect = this.canvas.getBoundingClientRect();
                const width = canvasRect.width;
                const height = canvasRect.height;
                
                this.ctx.clearRect(0, 0, width, height);
                
                // 배경 그라데이션
                const bgGradient = this.ctx.createLinearGradient(0, 0, 0, height);
                bgGradient.addColorStop(0, '#000033');
                bgGradient.addColorStop(1, '#000066');
                this.ctx.fillStyle = bgGradient;
                this.ctx.fillRect(0, 0, width, height);
                
                // RGB 세 픽셀 나란히 배치
                const totalPixelWidth = Math.min(width * 0.8, 600);
                const singlePixelWidth = totalPixelWidth / 3;
                const pixelHeight = Math.min(height * 0.7, 350);
                const startX = (width - totalPixelWidth) / 2;
                const startY = height * 0.15;
                
                // 입사광 그리기
                this.drawIncomingLight(startX, startY, totalPixelWidth, pixelHeight);
                
                // RGB 각 픽셀 그리기
                const filterTypes = ['red', 'green', 'blue'];
                const filterColors = ['#ff4444', '#44ff44', '#4444ff'];
                
                // 실리콘 영역 경계 계산
                let siliconBounds = null;
                if (this.settings.showSilicon && this.settings.animateLight) {
                    const lensHeight = this.settings.showMicrolens ? singlePixelWidth * 0.45 * 0.5 : 0;
                    const filterHeight = this.settings.showColorFilter ? pixelHeight * 0.06 : 0;
                    const siliconY = startY + lensHeight + 24 + filterHeight + 8;
                    const siliconHeight = pixelHeight * 0.4;
                    
                    siliconBounds = {
                        left: startX,
                        right: startX + totalPixelWidth,
                        top: siliconY,
                        bottom: siliconY + siliconHeight
                    };
                }
                
                for (let i = 0; i < 3; i++) {
                    const pixelX = startX + i * singlePixelWidth;
                    this.drawSinglePixel(pixelX, startY, singlePixelWidth, pixelHeight, filterTypes[i], filterColors[i]);
                }
                
                // 입자 물리 시뮬레이션 및 렌더링
                if (this.settings.animateLight) {
                    this.updatePhotons(siliconBounds);
                    this.updateElectrons();
                    this.renderParticles();
                }
                
                // 전체 레이블
                this.drawLabels(startX, startY, totalPixelWidth, pixelHeight);
            }
            
            drawSinglePixel(startX, startY, pixelWidth, pixelHeight, filterType, filterColor) {
                let currentY = startY;
                const layerSpacing = 8;
                
                // 1. 마이크로렌즈
                let lensHeight = 0;
                if (this.settings.showMicrolens) {
                    lensHeight = this.drawMicrolens(startX, currentY, pixelWidth, pixelHeight);
                    currentY += lensHeight + layerSpacing * 3;
                }
                
                // 2. 컬러 필터
                if (this.settings.showColorFilter) {
                    const filterHeight = pixelHeight * 0.06;
                    this.drawColorFilter(startX, currentY, pixelWidth, filterHeight, filterType, filterColor);
                    currentY += filterHeight + layerSpacing;
                }
                
                // 3. 실리콘 기판
                if (this.settings.showSilicon) {
                    const siliconHeight = pixelHeight * 0.4;
                    this.drawSiliconSubstrate(startX, currentY, pixelWidth, siliconHeight, filterType);
                    currentY += siliconHeight + layerSpacing;
                }
                
                // 4. 배선층
                if (this.settings.showWiring) {
                    const wiringHeight = pixelHeight * 0.12;
                    this.drawWiring(startX, currentY, pixelWidth, wiringHeight);
                }
            }
            
            drawIncomingLight(startX, startY, totalPixelWidth, pixelHeight) {
                if (this.settings.animateLight) return; // 애니메이션 모드에서는 파티클로 처리
                
                const rgb = this.wavelengthToRGB(this.settings.wavelength);
                const intensity = this.settings.lightIntensity / 100;
                const angle = this.settings.lightAngle * Math.PI / 180;
                
                const lightColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${intensity * 0.8})`;
                
                const numRays = 12;
                const raySpacing = totalPixelWidth * 1.2 / numRays;
                
                for (let i = 0; i < numRays; i++) {
                    const rayX = startX - totalPixelWidth * 0.1 + i * raySpacing;
                    const rayStartY = startY - 60;
                    const rayEndX = rayX + Math.sin(angle) * pixelHeight * 0.5;
                    const rayEndY = startY + pixelHeight * 0.3;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(rayX, rayStartY);
                    this.ctx.lineTo(rayEndX, rayEndY);
                    this.ctx.strokeStyle = lightColor;
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                    
                    this.drawArrow(rayX, rayStartY, rayEndX, rayEndY, lightColor);
                }
            }
            
            drawArrow(fromX, fromY, toX, toY, color) {
                const headLength = 8;
                const angle = Math.atan2(toY - fromY, toX - fromX);
                
                this.ctx.beginPath();
                this.ctx.moveTo(toX, toY);
                this.ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6), 
                               toY - headLength * Math.sin(angle - Math.PI / 6));
                this.ctx.moveTo(toX, toY);
                this.ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6), 
                               toY - headLength * Math.sin(angle + Math.PI / 6));
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 1.5;
                this.ctx.stroke();
            }
            
            drawMicrolens(startX, startY, pixelWidth, pixelHeight) {
                const centerX = startX + pixelWidth / 2;
                const lensRadius = pixelWidth * 0.45;
                const lensHeight = lensRadius * 0.5;
                
                // 렌즈 본체
                this.ctx.beginPath();
                this.ctx.arc(centerX, startY + lensHeight, lensRadius, Math.PI, 0, false);
                
                const lensGradient = this.ctx.createRadialGradient(centerX, startY + lensHeight/2, 0, centerX, startY + lensHeight/2, lensRadius);
                lensGradient.addColorStop(0, 'rgba(180, 220, 255, 0.9)');
                lensGradient.addColorStop(0.7, 'rgba(120, 170, 255, 0.7)');
                lensGradient.addColorStop(1, 'rgba(80, 120, 200, 0.5)');
                this.ctx.fillStyle = lensGradient;
                this.ctx.fill();
                
                // 렌즈 테두리
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.lineWidth = 1.5;
                this.ctx.stroke();
                
                return lensHeight;
            }
            
            drawColorFilter(startX, startY, pixelWidth, filterHeight, filterType, filterColor) {
                const transmittance = this.getFilterTransmittance(this.settings.wavelength, filterType);
                
                // 필터 본체
                const filterGradient = this.ctx.createLinearGradient(startX, startY, startX, startY + filterHeight);
                filterGradient.addColorStop(0, filterColor + '40');
                filterGradient.addColorStop(0.5, filterColor + 'AA');
                filterGradient.addColorStop(1, filterColor + '60');
                
                this.ctx.fillStyle = filterGradient;
                this.ctx.fillRect(startX, startY, pixelWidth, filterHeight);
                
                // 테두리
                this.ctx.strokeStyle = filterColor;
                this.ctx.lineWidth = 1.5;
                this.ctx.strokeRect(startX, startY, pixelWidth, filterHeight);
                
                // 투과된 빛
                if (transmittance > 0.05) {
                    const rgb = this.wavelengthToRGB(this.settings.wavelength);
                    const transmittedColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${transmittance * 0.8})`;
                    
                    const numBeams = 3;
                    for (let i = 0; i < numBeams; i++) {
                        const beamX = startX + (pixelWidth / (numBeams + 1)) * (i + 1);
                        this.ctx.beginPath();
                        this.ctx.moveTo(beamX, startY + filterHeight);
                        this.ctx.lineTo(beamX, startY + filterHeight + 12);
                        this.ctx.strokeStyle = transmittedColor;
                        this.ctx.lineWidth = Math.max(1, transmittance * 3);
                        this.ctx.stroke();
                    }
                }
                
                // 필터 레이블
                this.ctx.font = '9px Arial';
                this.ctx.fillStyle = 'white';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(filterType.charAt(0).toUpperCase(), startX + pixelWidth/2, startY + filterHeight/2 + 2);
                this.ctx.textAlign = 'left';
            }
            
            drawSiliconSubstrate(startX, startY, pixelWidth, siliconHeight, filterType) {
                // 실리콘 기판
                const siliconGradient = this.ctx.createLinearGradient(startX, startY, startX, startY + siliconHeight);
                siliconGradient.addColorStop(0, 'rgba(100, 100, 150, 0.8)');
                siliconGradient.addColorStop(0.3, 'rgba(120, 120, 180, 0.9)');
                siliconGradient.addColorStop(1, 'rgba(80, 80, 140, 0.8)');
                
                this.ctx.fillStyle = siliconGradient;
                this.ctx.fillRect(startX, startY, pixelWidth, siliconHeight);
                
                // 테두리
                this.ctx.strokeStyle = 'rgba(150, 150, 200, 0.8)';
                this.ctx.lineWidth = 1.5;
                this.ctx.strokeRect(startX, startY, pixelWidth, siliconHeight);
                
                // 애니메이션이 비활성화일 때만 정적 전자-정공 쌍 표시
                if (!this.settings.animateLight) {
                    const transmittance = this.getFilterTransmittance(this.settings.wavelength, filterType);
                    const numPairs = Math.floor(transmittance * this.settings.lightIntensity / 15);
                    
                    for (let i = 0; i < numPairs; i++) {
                        const pairX = startX + Math.random() * pixelWidth;
                        const pairY = startY + Math.random() * siliconHeight;
                        
                        // 전자
                        this.ctx.beginPath();
                        this.ctx.arc(pairX - 2, pairY, 1.5, 0, Math.PI * 2);
                        this.ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
                        this.ctx.fill();
                        
                        // 정공
                        this.ctx.beginPath();
                        this.ctx.arc(pairX + 2, pairY, 1.5, 0, Math.PI * 2);
                        this.ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
                        this.ctx.fill();
                    }
                }
                
                // Si 레이블
                this.ctx.font = '8px Arial';
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Si', startX + pixelWidth/2, startY + siliconHeight/2 + 2);
                this.ctx.textAlign = 'left';
                
                // 광전 변환 영역 표시
                if (this.settings.animateLight) {
                    this.ctx.font = '10px Arial';
                    this.ctx.fillStyle = 'rgba(255, 255, 100, 0.7)';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('광전 변환 영역', startX + pixelWidth/2, startY + 15);
                    this.ctx.textAlign = 'left';
                }
            }
            
            drawWiring(startX, startY, pixelWidth, wiringHeight) {
                const metalColor = 'rgba(200, 200, 200, 0.9)';
                const insulatorColor = 'rgba(100, 100, 150, 0.6)';
                
                // 절연층
                this.ctx.fillStyle = insulatorColor;
                this.ctx.fillRect(startX, startY, pixelWidth, wiringHeight);
                
                // 금속 배선
                const wireWidth = pixelWidth * 0.12;
                const wireSpacing = pixelWidth * 0.2;
                
                for (let i = 0; i < 3; i++) {
                    const wireX = startX + i * wireSpacing + wireWidth;
                    
                    this.ctx.fillStyle = metalColor;
                    this.ctx.fillRect(wireX, startY + wiringHeight * 0.2, wireWidth, wiringHeight * 0.6);
                    
                    // 비아
                    this.ctx.beginPath();
                    this.ctx.arc(wireX + wireWidth/2, startY + wiringHeight * 0.1, wireWidth/3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // 테두리
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(startX, startY, pixelWidth, wiringHeight);
            }
            
            drawLabels(startX, startY, totalPixelWidth, pixelHeight) {
                this.ctx.font = '12px Arial';
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                
                const labelX = startX + totalPixelWidth + 15;
                let labelY = startY;
                
                if (this.settings.showMicrolens) {
                    this.ctx.fillText('마이크로렌즈', labelX, labelY + 20);
                    labelY += 40;
                }
                
                if (this.settings.showColorFilter) {
                    this.ctx.fillText('컬러 필터', labelX, labelY + 20);
                    labelY += 40;
                }
                
                if (this.settings.showSilicon) {
                    this.ctx.fillText('실리콘 기판', labelX, labelY + 20);
                    labelY += 80;
                }
                
                if (this.settings.showWiring) {
                    this.ctx.fillText('배선층', labelX, labelY + 20);
                }
                
                // RGB 레이블
                this.ctx.font = '14px Arial';
                this.ctx.fillStyle = '#ff6b6b';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('R', startX + totalPixelWidth/6, startY - 10);
                
                this.ctx.fillStyle = '#4ecdc4';
                this.ctx.fillText('G', startX + totalPixelWidth/2, startY - 10);
                
                this.ctx.fillStyle = '#45b7d1';
                this.ctx.fillText('B', startX + totalPixelWidth * 5/6, startY - 10);
                
                this.ctx.textAlign = 'left';
            }
            
            drawSpectrum() {
                const canvasRect = this.spectrumCanvas.getBoundingClientRect();
                const width = canvasRect.width;
                const height = canvasRect.height;
                
                this.spectrumCtx.clearRect(0, 0, width, height);
                
                // 배경
                this.spectrumCtx.fillStyle = '#000';
                this.spectrumCtx.fillRect(0, 0, width, height);
                
                // 스펙트럼 그래프
                const startWavelength = 400;
                const endWavelength = 700;
                const wavelengthRange = endWavelength - startWavelength;
                const filterTypes = ['red', 'green', 'blue'];
                const filterColors = ['#ff6b6b', '#4ecdc4', '#45b7d1'];
                
                // RGB 필터 곡선들
                filterTypes.forEach((filterType, index) => {
                    this.spectrumCtx.beginPath();
                    
                    for (let i = 0; i < width; i++) {
                        const wavelength = startWavelength + (i / width) * wavelengthRange;
                        const transmittance = this.getFilterTransmittance(wavelength, filterType);
                        const graphY = height - (transmittance * height * 0.8) - height * 0.1;
                        
                        if (i === 0) {
                            this.spectrumCtx.moveTo(i, graphY);
                        } else {
                            this.spectrumCtx.lineTo(i, graphY);
                        }
                    }
                    
                    this.spectrumCtx.strokeStyle = filterColors[index];
                    this.spectrumCtx.lineWidth = 2.5;
                    this.spectrumCtx.stroke();
                });
                
                // 현재 파장 표시
                const currentWavelengthX = ((this.settings.wavelength - startWavelength) / wavelengthRange) * width;
                
                // 수직선
                this.spectrumCtx.beginPath();
                this.spectrumCtx.moveTo(currentWavelengthX, height);
                this.spectrumCtx.lineTo(currentWavelengthX, 0);
                this.spectrumCtx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                this.spectrumCtx.lineWidth = 1;
                this.spectrumCtx.setLineDash([5, 5]);
                this.spectrumCtx.stroke();
                this.spectrumCtx.setLineDash([]);
                
                // 각 필터에서의 현재 파장 점들
                filterTypes.forEach((filterType, index) => {
                    const currentTransmittance = this.getFilterTransmittance(this.settings.wavelength, filterType);
                    const currentY = height - (currentTransmittance * height * 0.8) - height * 0.1;
                    
                    this.spectrumCtx.beginPath();
                    this.spectrumCtx.arc(currentWavelengthX, currentY, 4, 0, Math.PI * 2);
                    this.spectrumCtx.fillStyle = filterColors[index];
                    this.spectrumCtx.fill();
                    this.spectrumCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    this.spectrumCtx.lineWidth = 1.5;
                    this.spectrumCtx.stroke();
                });
                
                // 축 레이블
                this.spectrumCtx.font = '10px Arial';
                this.spectrumCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                
                // X축
                for (let wavelength = 400; wavelength <= 700; wavelength += 50) {
                    const x = ((wavelength - startWavelength) / wavelengthRange) * width;
                    this.spectrumCtx.fillText(wavelength + 'nm', x - 15, height - 5);
                }
                
                // Y축
                this.spectrumCtx.fillText('100%', 5, 15);
                this.spectrumCtx.fillText('50%', 5, height/2);
                this.spectrumCtx.fillText('0%', 5, height - 5);
                
                // 범례
                this.spectrumCtx.font = '12px Arial';
                const legendX = width - 80;
                filterTypes.forEach((filterType, index) => {
                    const legendY = 20 + index * 20;
                    this.spectrumCtx.fillStyle = filterColors[index];
                    this.spectrumCtx.fillText(filterType.toUpperCase() + ' 필터', legendX, legendY);
                });
            }
            
            updateInfo() {
                // RGB 각 필터의 평균 투과율
                const redTransmittance = this.getFilterTransmittance(this.settings.wavelength, 'red');
                const greenTransmittance = this.getFilterTransmittance(this.settings.wavelength, 'green');
                const blueTransmittance = this.getFilterTransmittance(this.settings.wavelength, 'blue');
                const avgTransmittance = (redTransmittance + greenTransmittance + blueTransmittance) / 3;
                
                const microlensEfficiency = this.settings.showMicrolens ? 0.92 : 0.85;
                const angleEfficiency = Math.cos(this.settings.lightAngle * Math.PI / 180);
                const lightGathering = microlensEfficiency * angleEfficiency;
                const reachRate = avgTransmittance * lightGathering * (this.settings.lightIntensity / 100);
                
                document.getElementById('transmittance').textContent = Math.round(avgTransmittance * 100) + '%';
                document.getElementById('lightGathering').textContent = Math.round(lightGathering * 100) + '%';
                document.getElementById('reachRate').textContent = Math.round(reachRate * 100) + '%';
            }
            
            startAnimation() {
                setTimeout(() => {
                    this.drawPixelStructure();
                    this.drawSpectrum();
                    this.updateInfo();
                    
                    if (this.settings.animateLight) {
                        this.startContinuousAnimation();
                    }
                }, 100);
            }
            
            startContinuousAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                
                const animate = () => {
                    if (this.settings.animateLight) {
                        this.time += 0.016; // ~60fps
                        this.drawPixelStructure();
                        this.animationId = requestAnimationFrame(animate);
                    }
                };
                
                animate();
            }
            
            stopAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }
        }
        
        // 페이지 로드 시 시뮬레이터 시작
        window.addEventListener('load', () => {
            window.simulator = new SubPixelSimulator();
        });
        
        // 윈도우 리사이즈 시 캔버스 재조정
        window.addEventListener('resize', () => {
            setTimeout(() => {
                if (window.simulator) {
                    window.simulator.setupCanvas();
                    window.simulator.drawPixelStructure();
                    window.simulator.drawSpectrum();
                }
            }, 100);
        });
    </script>
</body>
</html>